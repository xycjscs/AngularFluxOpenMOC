# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
A method of characteristics code for nuclear reactor physics calculations.
"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_openmoc', [dirname(__file__)])
        except ImportError:
            import _openmoc
            return _openmoc
        if fp is not None:
            try:
                _mod = imp.load_module('_openmoc', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _openmoc = swig_import_helper()
    del swig_import_helper
else:
    import _openmoc
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def castUniverseToLattice(universe):
    return _openmoc.castUniverseToLattice(universe)
castUniverseToLattice = _openmoc.castUniverseToLattice

def castLatticeToUniverse(lattice):
    return _openmoc.castLatticeToUniverse(lattice)
castLatticeToUniverse = _openmoc.castLatticeToUniverse

def castSurfaceToPlane(plane):
    return _openmoc.castSurfaceToPlane(plane)
castSurfaceToPlane = _openmoc.castSurfaceToPlane

def castSurfaceToXPlane(xplane):
    return _openmoc.castSurfaceToXPlane(xplane)
castSurfaceToXPlane = _openmoc.castSurfaceToXPlane

def castSurfaceToYPlane(yplane):
    return _openmoc.castSurfaceToYPlane(yplane)
castSurfaceToYPlane = _openmoc.castSurfaceToYPlane

def castSurfaceToZPlane(zplane):
    return _openmoc.castSurfaceToZPlane(zplane)
castSurfaceToZPlane = _openmoc.castSurfaceToZPlane

def castSurfaceToZCylinder(zcylinder):
    return _openmoc.castSurfaceToZCylinder(zcylinder)
castSurfaceToZCylinder = _openmoc.castSurfaceToZCylinder
class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmoc.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _openmoc.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _openmoc.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _openmoc.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _openmoc.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _openmoc.SwigPyIterator_equal(self, x)

    def copy(self):
        return _openmoc.SwigPyIterator_copy(self)

    def next(self):
        return _openmoc.SwigPyIterator_next(self)

    def __next__(self):
        return _openmoc.SwigPyIterator___next__(self)

    def previous(self):
        return _openmoc.SwigPyIterator_previous(self)

    def advance(self, n):
        return _openmoc.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _openmoc.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _openmoc.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _openmoc.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _openmoc.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _openmoc.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _openmoc.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _openmoc.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class DoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmoc.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmoc.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _openmoc.DoubleVector___bool__(self)

    def __len__(self):
        return _openmoc.DoubleVector___len__(self)

    def pop(self):
        return _openmoc.DoubleVector_pop(self)

    def __getslice__(self, i, j):
        return _openmoc.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args, **kwargs):
        return _openmoc.DoubleVector___setslice__(self, *args, **kwargs)

    def __delslice__(self, i, j):
        return _openmoc.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _openmoc.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _openmoc.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _openmoc.DoubleVector___setitem__(self, *args)

    def append(self, x):
        return _openmoc.DoubleVector_append(self, x)

    def empty(self):
        return _openmoc.DoubleVector_empty(self)

    def size(self):
        return _openmoc.DoubleVector_size(self)

    def clear(self):
        return _openmoc.DoubleVector_clear(self)

    def swap(self, v):
        return _openmoc.DoubleVector_swap(self, v)

    def get_allocator(self):
        return _openmoc.DoubleVector_get_allocator(self)

    def begin(self):
        return _openmoc.DoubleVector_begin(self)

    def end(self):
        return _openmoc.DoubleVector_end(self)

    def rbegin(self):
        return _openmoc.DoubleVector_rbegin(self)

    def rend(self):
        return _openmoc.DoubleVector_rend(self)

    def pop_back(self):
        return _openmoc.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _openmoc.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _openmoc.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _openmoc.DoubleVector_push_back(self, x)

    def front(self):
        return _openmoc.DoubleVector_front(self)

    def back(self):
        return _openmoc.DoubleVector_back(self)

    def assign(self, n, x):
        return _openmoc.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _openmoc.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _openmoc.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _openmoc.DoubleVector_reserve(self, n)

    def capacity(self):
        return _openmoc.DoubleVector_capacity(self)
    __swig_destroy__ = _openmoc.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _openmoc.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmoc.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmoc.IntVector___nonzero__(self)

    def __bool__(self):
        return _openmoc.IntVector___bool__(self)

    def __len__(self):
        return _openmoc.IntVector___len__(self)

    def pop(self):
        return _openmoc.IntVector_pop(self)

    def __getslice__(self, i, j):
        return _openmoc.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args, **kwargs):
        return _openmoc.IntVector___setslice__(self, *args, **kwargs)

    def __delslice__(self, i, j):
        return _openmoc.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _openmoc.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _openmoc.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _openmoc.IntVector___setitem__(self, *args)

    def append(self, x):
        return _openmoc.IntVector_append(self, x)

    def empty(self):
        return _openmoc.IntVector_empty(self)

    def size(self):
        return _openmoc.IntVector_size(self)

    def clear(self):
        return _openmoc.IntVector_clear(self)

    def swap(self, v):
        return _openmoc.IntVector_swap(self, v)

    def get_allocator(self):
        return _openmoc.IntVector_get_allocator(self)

    def begin(self):
        return _openmoc.IntVector_begin(self)

    def end(self):
        return _openmoc.IntVector_end(self)

    def rbegin(self):
        return _openmoc.IntVector_rbegin(self)

    def rend(self):
        return _openmoc.IntVector_rend(self)

    def pop_back(self):
        return _openmoc.IntVector_pop_back(self)

    def erase(self, *args):
        return _openmoc.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _openmoc.new_IntVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _openmoc.IntVector_push_back(self, x)

    def front(self):
        return _openmoc.IntVector_front(self)

    def back(self):
        return _openmoc.IntVector_back(self)

    def assign(self, n, x):
        return _openmoc.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _openmoc.IntVector_resize(self, *args)

    def insert(self, *args):
        return _openmoc.IntVector_insert(self, *args)

    def reserve(self, n):
        return _openmoc.IntVector_reserve(self, n)

    def capacity(self):
        return _openmoc.IntVector_capacity(self)
    __swig_destroy__ = _openmoc.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _openmoc.IntVector_swigregister
IntVector_swigregister(IntVector)

class Array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Array, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _openmoc.Array_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _openmoc.Array___nonzero__(self)

    def __bool__(self):
        return _openmoc.Array___bool__(self)

    def __len__(self):
        return _openmoc.Array___len__(self)

    def pop(self):
        return _openmoc.Array_pop(self)

    def __getslice__(self, i, j):
        return _openmoc.Array___getslice__(self, i, j)

    def __setslice__(self, *args, **kwargs):
        return _openmoc.Array___setslice__(self, *args, **kwargs)

    def __delslice__(self, i, j):
        return _openmoc.Array___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _openmoc.Array___delitem__(self, *args)

    def __getitem__(self, *args):
        return _openmoc.Array___getitem__(self, *args)

    def __setitem__(self, *args):
        return _openmoc.Array___setitem__(self, *args)

    def append(self, x):
        return _openmoc.Array_append(self, x)

    def empty(self):
        return _openmoc.Array_empty(self)

    def size(self):
        return _openmoc.Array_size(self)

    def clear(self):
        return _openmoc.Array_clear(self)

    def swap(self, v):
        return _openmoc.Array_swap(self, v)

    def get_allocator(self):
        return _openmoc.Array_get_allocator(self)

    def begin(self):
        return _openmoc.Array_begin(self)

    def end(self):
        return _openmoc.Array_end(self)

    def rbegin(self):
        return _openmoc.Array_rbegin(self)

    def rend(self):
        return _openmoc.Array_rend(self)

    def pop_back(self):
        return _openmoc.Array_pop_back(self)

    def erase(self, *args):
        return _openmoc.Array_erase(self, *args)

    def __init__(self, *args):
        this = _openmoc.new_Array(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _openmoc.Array_push_back(self, x)

    def front(self):
        return _openmoc.Array_front(self)

    def back(self):
        return _openmoc.Array_back(self)

    def assign(self, n, x):
        return _openmoc.Array_assign(self, n, x)

    def resize(self, *args):
        return _openmoc.Array_resize(self, *args)

    def insert(self, *args):
        return _openmoc.Array_insert(self, *args)

    def reserve(self, n):
        return _openmoc.Array_reserve(self, n)

    def capacity(self):
        return _openmoc.Array_capacity(self)
    __swig_destroy__ = _openmoc.delete_Array
    __del__ = lambda self: None
Array_swigregister = _openmoc.Array_swigregister
Array_swigregister(Array)


_openmoc.REPORT_WIDTH_swigconstant(_openmoc)
REPORT_WIDTH = _openmoc.REPORT_WIDTH

_openmoc.DEFAULT_INIT_ID_swigconstant(_openmoc)
DEFAULT_INIT_ID = _openmoc.DEFAULT_INIT_ID

_openmoc.FOUR_PI_swigconstant(_openmoc)
FOUR_PI = _openmoc.FOUR_PI

_openmoc.ONE_OVER_FOUR_PI_swigconstant(_openmoc)
ONE_OVER_FOUR_PI = _openmoc.ONE_OVER_FOUR_PI

_openmoc.ZERO_SIGMA_T_swigconstant(_openmoc)
ZERO_SIGMA_T = _openmoc.ZERO_SIGMA_T

_openmoc.SIGMA_T_THRESH_swigconstant(_openmoc)
SIGMA_T_THRESH = _openmoc.SIGMA_T_THRESH

_openmoc.TINY_MOVE_swigconstant(_openmoc)
TINY_MOVE = _openmoc.TINY_MOVE

_openmoc.ON_LATTICE_CELL_THRESH_swigconstant(_openmoc)
ON_LATTICE_CELL_THRESH = _openmoc.ON_LATTICE_CELL_THRESH

_openmoc.ON_SURFACE_THRESH_swigconstant(_openmoc)
ON_SURFACE_THRESH = _openmoc.ON_SURFACE_THRESH

_openmoc.POLAR_WEIGHT_SUM_TOL_swigconstant(_openmoc)
POLAR_WEIGHT_SUM_TOL = _openmoc.POLAR_WEIGHT_SUM_TOL

_openmoc.TAU_NUDGE_swigconstant(_openmoc)
TAU_NUDGE = _openmoc.TAU_NUDGE

_openmoc.MIN_LINALG_POWER_ITERATIONS_swigconstant(_openmoc)
MIN_LINALG_POWER_ITERATIONS = _openmoc.MIN_LINALG_POWER_ITERATIONS

_openmoc.MAX_LINALG_POWER_ITERATIONS_swigconstant(_openmoc)
MAX_LINALG_POWER_ITERATIONS = _openmoc.MAX_LINALG_POWER_ITERATIONS

_openmoc.MIN_LINEAR_SOLVE_ITERATIONS_swigconstant(_openmoc)
MIN_LINEAR_SOLVE_ITERATIONS = _openmoc.MIN_LINEAR_SOLVE_ITERATIONS

_openmoc.MAX_LINEAR_SOLVE_ITERATIONS_swigconstant(_openmoc)
MAX_LINEAR_SOLVE_ITERATIONS = _openmoc.MAX_LINEAR_SOLVE_ITERATIONS

_openmoc.NUM_FACES_swigconstant(_openmoc)
NUM_FACES = _openmoc.NUM_FACES

_openmoc.NUM_EDGES_swigconstant(_openmoc)
NUM_EDGES = _openmoc.NUM_EDGES

_openmoc.NUM_SURFACES_swigconstant(_openmoc)
NUM_SURFACES = _openmoc.NUM_SURFACES

_openmoc.SURFACE_X_MIN_swigconstant(_openmoc)
SURFACE_X_MIN = _openmoc.SURFACE_X_MIN

_openmoc.SURFACE_Y_MIN_swigconstant(_openmoc)
SURFACE_Y_MIN = _openmoc.SURFACE_Y_MIN

_openmoc.SURFACE_X_MAX_swigconstant(_openmoc)
SURFACE_X_MAX = _openmoc.SURFACE_X_MAX

_openmoc.SURFACE_Y_MAX_swigconstant(_openmoc)
SURFACE_Y_MAX = _openmoc.SURFACE_Y_MAX

_openmoc.SURFACE_X_MIN_Y_MIN_swigconstant(_openmoc)
SURFACE_X_MIN_Y_MIN = _openmoc.SURFACE_X_MIN_Y_MIN

_openmoc.SURFACE_X_MAX_Y_MIN_swigconstant(_openmoc)
SURFACE_X_MAX_Y_MIN = _openmoc.SURFACE_X_MAX_Y_MIN

_openmoc.SURFACE_X_MAX_Y_MAX_swigconstant(_openmoc)
SURFACE_X_MAX_Y_MAX = _openmoc.SURFACE_X_MAX_Y_MAX

_openmoc.SURFACE_X_MIN_Y_MAX_swigconstant(_openmoc)
SURFACE_X_MIN_Y_MAX = _openmoc.SURFACE_X_MIN_Y_MAX

_openmoc.NUM_VALUES_PER_RETRIEVED_TRACK_swigconstant(_openmoc)
NUM_VALUES_PER_RETRIEVED_TRACK = _openmoc.NUM_VALUES_PER_RETRIEVED_TRACK

_openmoc.NUM_VALUES_PER_RETRIEVED_SEGMENT_swigconstant(_openmoc)
NUM_VALUES_PER_RETRIEVED_SEGMENT = _openmoc.NUM_VALUES_PER_RETRIEVED_SEGMENT

def cell_id():
    """

    cell_id() -> int  

    Returns an auto-generated unique Cell ID.  

    This method is intended as a utility method for users writing OpenMOC input files. The
    method makes use of a static Cell ID which is incremented each time the method is called
    to enable unique generation of monotonically increasing IDs. The method's first ID begins
    at 10000. Hence, user-defined Cell IDs greater than or equal to 10000 are prohibited.  

    """
    return _openmoc.cell_id()

def reset_cell_id():
    """

    reset_cell_id()  

    Resets the auto-generated unique Cell ID counter to 10000.  

    """
    return _openmoc.reset_cell_id()

def maximize_cell_id(cell_id):
    """

    maximize_cell_id(int cell_id)  

    Maximize the auto-generated unique Cell ID counter.  

    This method updates the auto-generated unique Cell ID counter if the input parameter is
    greater than the present value. This is useful for the OpenMC compatibility module to
    ensure that the auto-generated Cell IDs do not collide with those created in OpenMC.  

    Parameters
    ----------
    * cell_id :  
        the id assigned to the auto-generated counter  

    """
    return _openmoc.maximize_cell_id(cell_id)
class surface_halfspace(_object):
    """


    A surface_halfspace represents a surface pointer with associated halfspace.  

    Attributes
    ----------
    * _surface : Surface *  
        A pointer to the Surface object  

    * _halfspace : int  
        The halfspace associated with this surface  

    C++ includes: Cell.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, surface_halfspace, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, surface_halfspace, name)
    __repr__ = _swig_repr
    __swig_setmethods__["_surface"] = _openmoc.surface_halfspace__surface_set
    __swig_getmethods__["_surface"] = _openmoc.surface_halfspace__surface_get
    if _newclass:
        _surface = _swig_property(_openmoc.surface_halfspace__surface_get, _openmoc.surface_halfspace__surface_set)
    __swig_setmethods__["_halfspace"] = _openmoc.surface_halfspace__halfspace_set
    __swig_getmethods__["_halfspace"] = _openmoc.surface_halfspace__halfspace_get
    if _newclass:
        _halfspace = _swig_property(_openmoc.surface_halfspace__halfspace_get, _openmoc.surface_halfspace__halfspace_set)

    def __init__(self):
        """


        A surface_halfspace represents a surface pointer with associated halfspace.  

        Attributes
        ----------
        * _surface : Surface *  
            A pointer to the Surface object  

        * _halfspace : int  
            The halfspace associated with this surface  

        C++ includes: Cell.h

        """
        this = _openmoc.new_surface_halfspace()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_surface_halfspace
    __del__ = lambda self: None
surface_halfspace_swigregister = _openmoc.surface_halfspace_swigregister
surface_halfspace_swigregister(surface_halfspace)


_openmoc.MATERIAL_swigconstant(_openmoc)
MATERIAL = _openmoc.MATERIAL

_openmoc.FILL_swigconstant(_openmoc)
FILL = _openmoc.FILL

_openmoc.UNFILLED_swigconstant(_openmoc)
UNFILLED = _openmoc.UNFILLED
class Cell(_object):
    """


    Represents a Cell inside of a Universe.  

    C++ includes: src/Cell.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Cell, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Cell, name)
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """

        Cell(int id=0, const char *name="")  

        Constructor sets the unique and user-specifed IDs for this Cell.  

        Parameters
        ----------
        * id :  
            the user-specified optional Cell ID  
        * name :  
            the user-specified optional Cell name  

        """
        this = _openmoc.new_Cell(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Cell
    __del__ = lambda self: None

    def getUid(self):
        """

        getUid() const  -> int  

        Return the Cell's unique ID.  

        Returns
        -------
        the Cell's unique ID  

        """
        return _openmoc.Cell_getUid(self)


    def getId(self):
        """

        getId() const  -> int  

        Return the Cell's user-specified ID.  

        Returns
        -------
        the Cell's user-specified ID  

        """
        return _openmoc.Cell_getId(self)


    def getName(self):
        """

        getName() const  -> char *  

        Return the user-defined name of the Cell.  

        Returns
        -------
        the Cell name  

        """
        return _openmoc.Cell_getName(self)


    def getType(self):
        """

        getType() const  -> cellType  

        Return the Cell type (FILL or MATERIAL).  

        Returns
        -------
        the Cell type  

        """
        return _openmoc.Cell_getType(self)


    def getFillMaterial(self):
        """

        getFillMaterial() -> Material *  

        Return a pointer to the Material filling this Cell.  

        Returns
        -------
        the Material fill pointer  

        """
        return _openmoc.Cell_getFillMaterial(self)


    def getFillUniverse(self):
        """

        getFillUniverse() -> Universe *  

        Return a pointer to the Material filling this Cell.  

        Returns
        -------
        the Material fill pointer  

        """
        return _openmoc.Cell_getFillUniverse(self)


    def getVolume(self):
        """

        getVolume() -> double  

        Return the aggregate volume/area of all instances of this Cell.  

        The volume/area of the Cell is computed from track segments which overlap this Cell during
        track generation.  

        Returns
        -------
        the volume/area of the Cell  

        """
        return _openmoc.Cell_getVolume(self)


    def getNumInstances(self):
        """

        getNumInstances() -> int  

        Return the number of instances of this Cell in the Geometry.  

        The number of instances of this Cell in the Geometry is determined during track
        generation.  

        Returns
        -------
        the number of cell instances  

        """
        return _openmoc.Cell_getNumInstances(self)


    def isRotated(self):
        """

        isRotated() -> bool  

        Return a boolean indicating whether the Cell has been rotated.  

        Returns
        -------
        whether the Cell has been rotated  

        """
        return _openmoc.Cell_isRotated(self)


    def isTranslated(self):
        """

        isTranslated() -> bool  

        Return a boolean indicating whether the Cell has been translated.  

        Returns
        -------
        whether the Cell has been translated  

        """
        return _openmoc.Cell_isTranslated(self)


    def getPhi(self, *args, **kwargs):
        """

        getPhi(std::string units="degrees") -> double  

        Get the rotation angle about the x-axis in degrees.  

        Parameters
        ----------
        * units :  
            the angular units in "radians" or "degrees" (default)  

        Returns
        -------
        the rotation angle about the x-axis  

        """
        return _openmoc.Cell_getPhi(self, *args, **kwargs)


    def getTheta(self, *args, **kwargs):
        """

        getTheta(std::string units="degrees") -> double  

        Get the rotation angle about the y-axis in degrees.  

        Parameters
        ----------
        * units :  
            the angular units in "radians" or "degrees" (default)  

        Returns
        -------
        the rotation angle about the y-axis  

        """
        return _openmoc.Cell_getTheta(self, *args, **kwargs)


    def getPsi(self, *args, **kwargs):
        """

        getPsi(std::string units="degrees") -> double  

        Get the rotation angle about the z-axis in degrees.  

        Parameters
        ----------
        * units :  
            the angular units in "radians" or "degrees" (default)  

        Returns
        -------
        the rotation angle about the z-axis  

        """
        return _openmoc.Cell_getPsi(self, *args, **kwargs)


    def getRotationMatrix(self):
        """

        getRotationMatrix() -> double *  

        Return pointer to array for the rotation matrix.  

        Returns
        -------
        a pointer to an array of rotation angles  

        """
        return _openmoc.Cell_getRotationMatrix(self)


    def getTranslation(self):
        """

        getTranslation() -> double *  

        Return pointer to array for the translations along x, y and z.  

        Returns
        -------
        a pointer to an array of translations  

        """
        return _openmoc.Cell_getTranslation(self)


    def retrieveRotation(self, *args, **kwargs):
        """

        retrieveRotation(double *rotations, int num_axes, std::string units="degrees")  

        Fills an array with the rotation angles for x, y and z.  

        This class method is intended to be called by the OpenMOC Python OpenMC compatiblity
        module. Although this method appears to require two arguments, in reality it only requires
        one due to SWIG and would be called from within Python as follows:  


        Parameters
        ----------
        * rotation :  
            an array of rotation angles of length 3 for x, y and z  
        * num_axes :  
            the number of axes (this must always be 3)  
        * units :  
            the angular units in "radians" or "degrees" (default)  

        """
        return _openmoc.Cell_retrieveRotation(self, *args, **kwargs)


    def retrieveTranslation(self, translations):
        """

        retrieveTranslation(double *translations, int num_axes)  

        Fills an array with the translations along x, y and z.  

        This class method is intended to be called by the OpenMOC Python OpenMC compatiblity
        module. Although this method appears to require two arguments, in reality it only requires
        one due to SWIG and would be called from within Python as follows:  


        Parameters
        ----------
        * translation :  
            an array of translations of length 3 for x, y and z  
        * num_axes :  
            the number of axes (this must always be 3)  

        """
        return _openmoc.Cell_retrieveTranslation(self, translations)


    def getNumRings(self):
        """

        getNumRings() -> int  

        Return the number of rings in the Cell.  

        Returns
        -------
        the number of rings  

        """
        return _openmoc.Cell_getNumRings(self)


    def getNumSectors(self):
        """

        getNumSectors() -> int  

        Return the number of sectors in the Cell.  

        Returns
        -------
        the number of sectors  

        """
        return _openmoc.Cell_getNumSectors(self)


    def getMinX(self):
        """

        getMinX() -> double  

        Return the minimum reachable x-coordinate in the Cell.  

        Returns
        -------
        the minimum x-coordinate  

        """
        return _openmoc.Cell_getMinX(self)


    def getMaxX(self):
        """

        getMaxX() -> double  

        Return the maximum reachable x-coordinate in the Cell.  

        Returns
        -------
        the maximum x-coordinate  

        """
        return _openmoc.Cell_getMaxX(self)


    def getMinY(self):
        """

        getMinY() -> double  

        Return the minimum reachable y-coordinate in the Cell.  

        Returns
        -------
        the minimum y-coordinate  

        """
        return _openmoc.Cell_getMinY(self)


    def getMaxY(self):
        """

        getMaxY() -> double  

        Return the maximum reachable y-coordinate in the Cell.  

        Returns
        -------
        the maximum y-coordinate  

        """
        return _openmoc.Cell_getMaxY(self)


    def getMinZ(self):
        """

        getMinZ() -> double  

        Return the minimum reachable z-coordinate in the Cell.  

        Returns
        -------
        the minimum z-coordinate  

        """
        return _openmoc.Cell_getMinZ(self)


    def getMaxZ(self):
        """

        getMaxZ() -> double  

        Return the maximum reachable z-coordinate in the Cell.  

        Returns
        -------
        the maximum z-coordinate  

        """
        return _openmoc.Cell_getMaxZ(self)


    def getMinXBoundaryType(self):
        """

        getMinXBoundaryType() -> boundaryType  

        Return the boundary condition (REFLECTIVE, VACUUM, or INTERFACE) at the minimum reachable
        x-coordinate in the Cell.  

        Returns
        -------
        the boundary condition at the minimum x-coordinate  

        """
        return _openmoc.Cell_getMinXBoundaryType(self)


    def getMaxXBoundaryType(self):
        """

        getMaxXBoundaryType() -> boundaryType  

        Return the boundary condition (REFLECTIVE, VACUUM, or INTERFACE) at the maximum reachable
        x-coordinate in the Cell.  

        Returns
        -------
        the boundary condition at the maximum x-coordinate  

        """
        return _openmoc.Cell_getMaxXBoundaryType(self)


    def getMinYBoundaryType(self):
        """

        getMinYBoundaryType() -> boundaryType  

        Return the boundary condition (REFLECTIVE, VACUUM, or INTERFACE) at the minimum reachable
        y-coordinate in the Cell.  

        Returns
        -------
        the boundary condition at the minimum y-coordinate  

        """
        return _openmoc.Cell_getMinYBoundaryType(self)


    def getMaxYBoundaryType(self):
        """

        getMaxYBoundaryType() -> boundaryType  

        Return the boundary condition (REFLECTIVE, VACUUM, or INTERFACE) at the maximum reachable
        y-coordinate in the Cell.  

        Returns
        -------
        the boundary condition at the maximum y-coordinate  

        """
        return _openmoc.Cell_getMaxYBoundaryType(self)


    def getNumSurfaces(self):
        """

        getNumSurfaces() const  -> int  

        Return the number of Surfaces in the Cell.  

        Returns
        -------
        the number of Surfaces  

        """
        return _openmoc.Cell_getNumSurfaces(self)


    def getSurfaces(self):
        """

        getSurfaces() const  -> std::map< int, surface_halfspace * >  

        Return the std::map of Surface pointers and halfspaces (+/-1) for all surfaces bounding
        the Cell.  

        Returns
        -------
        std::map of Surface pointers and halfspaces  

        """
        return _openmoc.Cell_getSurfaces(self)


    def getNeighbors(self):
        """

        getNeighbors() const  -> std::vector< Cell * >  

        Return the std::vector of neighbor Cells to this Cell.  

        Returns
        -------
        std::vector of neighbor Cell pointers  

        """
        return _openmoc.Cell_getNeighbors(self)


    def hasParent(self):
        """

        hasParent() -> bool  

        Return true if the Cell has a parent and false otherwise.  

        Returns
        -------
        whether the Cell has a parent Cell  

        """
        return _openmoc.Cell_hasParent(self)


    def getParent(self):
        """

        getParent() -> Cell *  

        Return this Cell's parent Cell.  

        If no parent Cell has been assigned from Cell cloning, then NULL is returned.  

        Returns
        -------
        a pointer to the parent Cell  

        """
        return _openmoc.Cell_getParent(self)


    def getOldestAncestor(self):
        """

        getOldestAncestor() -> Cell *  

        Get the oldest ancestor Cell for this Cell.  

        This method traverses the linked list of parent Cells to find the one at the root node.
        The oldest ancestor Cell is likely the one created by the user at runtime, while
        intermediate ancestors were created during radial and angular spatial discretization.  

        Returns
        -------
        this Cell's oldest ancestor Cell  

        """
        return _openmoc.Cell_getOldestAncestor(self)


    def getAllCells(self):
        """

        getAllCells() -> std::map< int, Cell * >  

        Returns the std::map of Cell IDs and Cell pointers within any nested Universes filling
        this Cell.  

        Returns
        -------
        std::map of Cell IDs and pointers  

        """
        return _openmoc.Cell_getAllCells(self)


    def getAllUniverses(self):
        """

        getAllUniverses() -> std::map< int, Universe * >  

        Returns the std::map of all nested Universe IDs and Universe pointers filling this Cell.  

        Returns
        -------
        std::map of Universe IDs and pointers  

        """
        return _openmoc.Cell_getAllUniverses(self)


    def setName(self, name):
        """

        setName(const char *name)  

        Sets the name of the Cell.  

        Parameters
        ----------
        * name :  
            the Cell name string  

        """
        return _openmoc.Cell_setName(self, name)


    def setFill(self, *args):
        """

        setFill(Material *fill)  
        setFill(Universe *fill)  

        Overloaded function
        -------------------
        * setFill(Material *fill)  

            Sets the Material filling this Cell.  

            Parameters:  
            * fill :  
                the Material filling this Cell  

        * setFill(Universe *fill)  

            Sets the Universe filling this Cell.  

            Parameters:  
            * fill :  
                the Universe filling this Cell  

        """
        val = _openmoc.Cell_setFill(self, *args)

          # SWIG 3
        if 'fill' in locals():
          fill = locals()['fill']
        elif 'args' in locals() and 'fill' in locals()['args']:
          fill = locals()['args']['fill']
        elif 'kwargs' in locals() and 'fill' in locals()['kwargs']:
          fill = locals()['kwargs']['fill']

        # SWIG 2
        else:
          fill = locals()['args'][0]

        fill.thisown = False


        return val


    def setVolume(self, volume):
        """

        setVolume(double volume)  

        Set the volume/area of the Cell.  

        Parameters
        ----------
        * volume :  
            the volume/area of the Cell  

        """
        return _openmoc.Cell_setVolume(self, volume)


    def incrementVolume(self, volume):
        """

        incrementVolume(double volume)  

        Increment the volume/area of the Cell by some amount.  

        This routine is called by the TrackGenerator during track generation and segmentation.  

        Parameters
        ----------
        * volume :  
            the amount to increment the current volume by  

        """
        return _openmoc.Cell_incrementVolume(self, volume)


    def setNumInstances(self, num_instances):
        """

        setNumInstances(int num_instances)  

        Set the number of instances of this Cell.  

        Parameters
        ----------
        * num_instances :  
            the number of instances of this Cell in the Geometry  

        """
        return _openmoc.Cell_setNumInstances(self, num_instances)


    def incrementNumInstances(self):
        """

        incrementNumInstances()  

        Increment the number of instances of this Cell.  

        This routine is called by the TrackGenerator during track generation and segmentation.  

        """
        return _openmoc.Cell_incrementNumInstances(self)


    def setRotation(self, *args, **kwargs):
        """

        setRotation(double *rotation, int num_axes, std::string units="degrees")  

        Set the Cell's rotation angles about the x, y and z axes.  

        This method is a helper function to allow OpenMOC users to assign the Cell's rotation
        angles in Python. A user must initialize a length 3 NumPy array as input to this function.
        This function then stores the data values in the NumPy array in the Cell's rotation array.
        An example of how this function might be called in Python is as follows:  


        Parameters
        ----------
        * rotation :  
            the array of rotation angles  
        * num_axes :  
            the number of axes (this must always be 3)  
        * units :  
            the angular units in "radians" or "degrees" (default)  

        """
        return _openmoc.Cell_setRotation(self, *args, **kwargs)


    def setTranslation(self, translation):
        """

        setTranslation(double *translation, int num_axes)  

        Set the Cell's translation along the x, y and z axes.  

        This method is a helper function to allow OpenMOC users to assign the Cell's translations
        in Python. A user must initialize a length 3 NumPy array as input to this function. This
        function then stores the data values in the NumPy array in the Cell's translation array.
        An example of how this function might be called in Python is as follows:  


        Parameters
        ----------
        * translation :  
            the array of translations  
        * num_axes :  
            the number of axes (this must always be 3)  

        """
        return _openmoc.Cell_setTranslation(self, translation)


    def setNumRings(self, num_rings):
        """

        setNumRings(int num_rings)  

        Set the Cell's number of rings.  

        Parameters
        ----------
        * num_rings :  
            the number of rings in this Cell  

        """
        return _openmoc.Cell_setNumRings(self, num_rings)


    def setNumSectors(self, num_sectors):
        """

        setNumSectors(int num_sectors)  

        Set the Cell's number of sectors.  

        Parameters
        ----------
        * num_sectors :  
            the number of sectors in this Cell  

        """
        return _openmoc.Cell_setNumSectors(self, num_sectors)


    def setParent(self, parent):
        """

        setParent(Cell *parent)  

        Assign a parent Cell to this Cell.  

        This is used by Cell cloning when applied for radial and angular discretization.  

        Parameters
        ----------
        * parent :  
            a pointer to the parent Cell  

        """
        return _openmoc.Cell_setParent(self, parent)


    def addSurface(self, halfspace, surface):
        """

        addSurface(int halfspace, Surface *surface)  

        Insert a Surface into this Cell's container of bounding Surfaces.  

        Parameters
        ----------
        * halfspace :  
            the Surface halfspace (+/-1)  
        * surface :  
            a pointer to the Surface  

        """
        val = _openmoc.Cell_addSurface(self, halfspace, surface)

          # SWIG 3
        if 'surface'in locals():
          surface = locals()['surface']
        elif 'args' in locals() and 'surface' in locals()['args']:
          surface = locals()['args']['surface']
        elif 'kwargs' in locals() and 'surface' in locals()['kwargs']:
          surface = locals()['kwargs']['surface']

        # SWIG 2
        else:
          surface = locals()['args'][1]

        surface.thisown = False


        return val


    def removeSurface(self, surface):
        """

        removeSurface(Surface *surface)  

        Removes a Surface from this Cell's container of bounding Surfaces.  

        Parameters
        ----------
        * surface :  
            a pointer to the Surface to remove  

        """
        val = _openmoc.Cell_removeSurface(self, surface)

          # SWIG 3
        if 'surface' in locals():
          surface = locals()['surface']
        elif 'args' in locals() and 'surface' in locals()['args']:
          surface = locals()['args']['surface']
        elif 'kwargs' in locals() and 'surface' in locals()['kwargs']:
          surface = locals()['kwargs']['surface']

        # SWIG 2
        else:
          surface = locals()['args'][0]

        surface.thisown = True


        return val


    def addNeighborCell(self, cell):
        """

        addNeighborCell(Cell *cell)  

        Add a neighboring Cell to this Cell's collection of neighbors.  

        Parameters
        ----------
        * cell :  
            a pointer to the neighboring Cell  

        """
        return _openmoc.Cell_addNeighborCell(self, cell)


    def isFissionable(self):
        """

        isFissionable() -> bool  

        Returns true if this Cell is filled with a fissionable Material.  

        If the Cell is filled by a Material, this method will simply query the filling Material.
        If the Cell is filled by a Universe, this method will consider any Materials filling those
        Cells contained by the filling Universe. This method should not be called prior to the
        calling of the Geometry::computeFissionability() method.  

        Returns
        -------
        true if contains a fissionable Material  

        """
        return _openmoc.Cell_isFissionable(self)


    def containsPoint(self, point):
        """

        containsPoint(Point *point) -> bool  

        Determines whether a Point is contained inside a Cell.  

        Queries each Surface inside the Cell to determine if the Point is on the same side of the
        Surface. This point is only inside the Cell if it is on the same side of every Surface in
        the Cell.  

        Parameters
        ----------
        * point :  
            a pointer to a Point  

        """
        return _openmoc.Cell_containsPoint(self, point)


    def containsCoords(self, coords):
        """

        containsCoords(LocalCoords *coords) -> bool  

        Determines whether a Point is contained inside a Cell.  

        Queries each Surface inside the Cell to determine if the Point is on the same side of the
        Surface. This Point is only inside the Cell if it is on the same side of every Surface in
        the Cell.  

        Parameters
        ----------
        * coords :  
            a pointer to a localcoord  

        """
        return _openmoc.Cell_containsCoords(self, coords)


    def minSurfaceDist(self, coords):
        """

        minSurfaceDist(LocalCoords *coords) -> double  

        Computes the minimum distance to a Surface from a point with a given trajectory at a
        certain angle stored in a LocalCoords object.  

        If the trajectory will not intersect any of the Surfaces in the Cell returns INFINITY.  

        Parameters
        ----------
        * coords :  
            a pointer to a localcoords  

        """
        return _openmoc.Cell_minSurfaceDist(self, coords)


    def clone(self):
        """

        clone() -> Cell *  

        Create a duplicate of the Cell.  

        Returns
        -------
        a pointer to the clone  

        """
        return _openmoc.Cell_clone(self)


    def subdivideCell(self, max_radius):
        """

        subdivideCell(double max_radius)  

        Subdivides a Cell into rings and sectors aligned with the z-axis.  

        This method uses the Cell's clone method to produce a vector of this Cell's subdivided
        ring and sector Cells.  

        Parameters
        ----------
        * max_radius :  
            the maximum allowable radius used in the subdivisions  

        Returns
        -------
        a vector of Cell pointers to the new subdivided Cells  

        A container of all Cell clones created for rings and sectors  

        """
        return _openmoc.Cell_subdivideCell(self, max_radius)


    def buildNeighbors(self):
        """

        buildNeighbors()  

        Build a collection of neighboring Cells for optimized ray tracing.  

        """
        return _openmoc.Cell_buildNeighbors(self)


    def toString(self):
        """

        toString() -> std::string  

        Convert this Cell's attributes to a string format.  

        Returns
        -------
        a character array of this Cell's attributes  

        Add string data for the Surfaces in this Cell  

        """
        return _openmoc.Cell_toString(self)


    def printString(self):
        """

        printString()  

        Prints a string representation of all of the Cell's attributes to the console.  

        """
        return _openmoc.Cell_printString(self)

Cell_swigregister = _openmoc.Cell_swigregister
Cell_swigregister(Cell)

class fsr_data(_object):
    """


    A fsr_data struct represents an FSR with a unique FSR ID and a characteristic point that
    lies within the FSR that can be used to recompute the hierarchical LocalCoords linked
    list.  

    Attributes
    ----------
    * _fsr_id : int  
        The FSR ID  

    * _cmfd_cell : int  
        The CMFD Cell  

    * _mat_id : int  
        The Material ID  

    * _point : Point *  
        Characteristic point in Root Universe that lies in FSR  

    * _centroid : Point *  
        Global numerical centroid in Root Universe  

    C++ includes: Geometry.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fsr_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fsr_data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["_fsr_id"] = _openmoc.fsr_data__fsr_id_set
    __swig_getmethods__["_fsr_id"] = _openmoc.fsr_data__fsr_id_get
    if _newclass:
        _fsr_id = _swig_property(_openmoc.fsr_data__fsr_id_get, _openmoc.fsr_data__fsr_id_set)
    __swig_setmethods__["_cmfd_cell"] = _openmoc.fsr_data__cmfd_cell_set
    __swig_getmethods__["_cmfd_cell"] = _openmoc.fsr_data__cmfd_cell_get
    if _newclass:
        _cmfd_cell = _swig_property(_openmoc.fsr_data__cmfd_cell_get, _openmoc.fsr_data__cmfd_cell_set)
    __swig_setmethods__["_mat_id"] = _openmoc.fsr_data__mat_id_set
    __swig_getmethods__["_mat_id"] = _openmoc.fsr_data__mat_id_get
    if _newclass:
        _mat_id = _swig_property(_openmoc.fsr_data__mat_id_get, _openmoc.fsr_data__mat_id_set)
    __swig_setmethods__["_point"] = _openmoc.fsr_data__point_set
    __swig_getmethods__["_point"] = _openmoc.fsr_data__point_get
    if _newclass:
        _point = _swig_property(_openmoc.fsr_data__point_get, _openmoc.fsr_data__point_set)
    __swig_setmethods__["_centroid"] = _openmoc.fsr_data__centroid_set
    __swig_getmethods__["_centroid"] = _openmoc.fsr_data__centroid_get
    if _newclass:
        _centroid = _swig_property(_openmoc.fsr_data__centroid_get, _openmoc.fsr_data__centroid_set)

    def __init__(self):
        """

        fsr_data()  

        Constructor for FSR data initializes centroids and points to NULL  

        """
        this = _openmoc.new_fsr_data()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_fsr_data
    __del__ = lambda self: None
fsr_data_swigregister = _openmoc.fsr_data_swigregister
fsr_data_swigregister(fsr_data)


def reset_auto_ids():
    """

    reset_auto_ids()  

    Resets the auto-generated unique IDs for Materials, Surfaces, Cells and Universes/Lattices
    to 10000.  

    """
    return _openmoc.reset_auto_ids()
class Geometry(_object):
    """


    The master class containing references to all geometry-related objects - Surfaces, Cells,
    Universes and Lattices - and Materials.  

    The primary purpose for the geometry is to serve as a collection of all geometry-related
    objects, as well as for ray tracing of characteristic tracks across the Geometry and
    computing FSR-to-cell offset maps.  

    C++ includes: src/Geometry.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Geometry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Geometry, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        Geometry()  

        Constructor initializes an empty Geometry.  

        """
        this = _openmoc.new_Geometry()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Geometry
    __del__ = lambda self: None

    def getWidthX(self):
        """

        getWidthX() -> double  

        Returns the total width in the x-direction of the Geometry in cm.  

        Returns
        -------
        the total width of the Geometry in the x-direction (cm)  

        """
        return _openmoc.Geometry_getWidthX(self)


    def getWidthY(self):
        """

        getWidthY() -> double  

        Returns the total width in the y-direction of the Geometry in cm.  

        Returns
        -------
        the total width of the Geometry in the y-direction (cm)  

        """
        return _openmoc.Geometry_getWidthY(self)


    def getWidthZ(self):
        """

        getWidthZ() -> double  

        Returns the total width in the z-direction of the Geometry in cm.  

        Returns
        -------
        the total width of the Geometry in the z-direction (cm)  

        """
        return _openmoc.Geometry_getWidthZ(self)


    def getMinX(self):
        """

        getMinX() -> double  

        Return the minimum x-coordinate contained by the Geometry.  

        Returns
        -------
        the minimum x-coordinate (cm)  

        """
        return _openmoc.Geometry_getMinX(self)


    def getMaxX(self):
        """

        getMaxX() -> double  

        Return the maximum x-coordinate contained by the Geometry.  

        Returns
        -------
        the maximum x-coordinate (cm)  

        """
        return _openmoc.Geometry_getMaxX(self)


    def getMinY(self):
        """

        getMinY() -> double  

        Return the minimum y-coordinate contained by the Geometry.  

        Returns
        -------
        the minimum y-coordinate (cm)  

        """
        return _openmoc.Geometry_getMinY(self)


    def getMaxY(self):
        """

        getMaxY() -> double  

        Return the maximum y-coordinate contained by the Geometry.  

        Returns
        -------
        the maximum y-coordinate (cm)  

        """
        return _openmoc.Geometry_getMaxY(self)


    def getMinZ(self):
        """

        getMinZ() -> double  

        Return the minimum z-coordinate contained by the Geometry.  

        Returns
        -------
        the minimum z-coordinate (cm)  

        """
        return _openmoc.Geometry_getMinZ(self)


    def getMaxZ(self):
        """

        getMaxZ() -> double  

        Return the maximum z-coordinate contained by the Geometry.  

        Returns
        -------
        the maximum z-coordinate (cm)  

        """
        return _openmoc.Geometry_getMaxZ(self)


    def getMinXBoundaryType(self):
        """

        getMinXBoundaryType() -> boundaryType  

        Returns the boundary conditions (REFLECTIVE or VACUUM) at the minimum x-coordinate in the
        Geometry.  

        Returns
        -------
        the boundary conditions for the minimum x-coordinate in the Geometry  

        """
        return _openmoc.Geometry_getMinXBoundaryType(self)


    def getMaxXBoundaryType(self):
        """

        getMaxXBoundaryType() -> boundaryType  

        Returns the boundary conditions (REFLECTIVE or VACUUM) at the maximum x-coordinate in the
        Geometry.  

        Returns
        -------
        the boundary conditions for the maximum z-coordinate in the Geometry  

        """
        return _openmoc.Geometry_getMaxXBoundaryType(self)


    def getMinYBoundaryType(self):
        """

        getMinYBoundaryType() -> boundaryType  

        Returns the boundary conditions (REFLECTIVE or VACUUM) at the minimum y-coordinate in the
        Geometry.  

        Returns
        -------
        the boundary conditions for the minimum y-coordinate in the Geometry  

        """
        return _openmoc.Geometry_getMinYBoundaryType(self)


    def getMaxYBoundaryType(self):
        """

        getMaxYBoundaryType() -> boundaryType  

        Returns the boundary conditions (REFLECTIVE or VACUUM) at the maximum y-coordinate in the
        Geometry.  

        Returns
        -------
        the boundary conditions for the maximum y-coordinate in the Geometry  

        """
        return _openmoc.Geometry_getMaxYBoundaryType(self)


    def getRootUniverse(self):
        """

        getRootUniverse() -> Universe *  

        Returns the Universe at the root node in the CSG tree.  

        Returns
        -------
        the root Universe  

        """
        return _openmoc.Geometry_getRootUniverse(self)


    def getNumFSRs(self):
        """

        getNumFSRs() -> int  

        Returns the number of flat source regions in the Geometry.  

        Returns
        -------
        number of FSRs  

        """
        return _openmoc.Geometry_getNumFSRs(self)


    def getNumEnergyGroups(self):
        """

        getNumEnergyGroups() -> int  

        Returns the number of energy groups for each Material's nuclear data.  

        Returns
        -------
        the number of energy groups  

        """
        return _openmoc.Geometry_getNumEnergyGroups(self)


    def getNumMaterials(self):
        """

        getNumMaterials() -> int  

        Returns the number of Materials in the Geometry.  

        Returns
        -------
        the number of Materials  

        """
        return _openmoc.Geometry_getNumMaterials(self)


    def getNumCells(self):
        """

        getNumCells() -> int  

        Returns the number of Cells in the Geometry.  

        Returns
        -------
        the number of Cells  

        """
        return _openmoc.Geometry_getNumCells(self)


    def getAllMaterials(self):
        """

        getAllMaterials() -> std::map< int, Material * >  

        Return a std::map container of Material IDs (keys) with Materials pointers (values).  

        Returns
        -------
        a std::map of Materials indexed by Material ID in the geometry  

        """
        return _openmoc.Geometry_getAllMaterials(self)


    def getAllSurfaces(self):
        """

        getAllSurfaces() -> std::map< int, Surface * >  

        Return a std::map container of Surface IDs (keys) with Surfaces pointers (values).  

        Returns
        -------
        a std::map of Surfaces indexed by Surface ID in the geometry  

        """
        return _openmoc.Geometry_getAllSurfaces(self)


    def getAllCells(self):
        """

        getAllCells() -> std::map< int, Cell * >  

        Return a std::map container of Cell IDs (keys) with Cells pointers (values).  

        Returns
        -------
        a std::map of Cells indexed by Cell ID in the geometry  

        """
        return _openmoc.Geometry_getAllCells(self)


    def getAllMaterialCells(self):
        """

        getAllMaterialCells() -> std::map< int, Cell * >  

        Return a std::map container of Cell IDs (keys) with Cells pointers (values).  

        Returns
        -------
        a std::map of Cells indexed by Cell ID in the geometry  

        """
        return _openmoc.Geometry_getAllMaterialCells(self)


    def getAllUniverses(self):
        """

        getAllUniverses() -> std::map< int, Universe * >  

        Return a std::map container of Universe IDs (keys) with Unierses pointers (values).  

        Returns
        -------
        a std::map of Universes indexed by Universe ID in the geometry  

        """
        return _openmoc.Geometry_getAllUniverses(self)


    def setRootUniverse(self, root_universe):
        """

        setRootUniverse(Universe *root_universe)  

        Sets the root Universe for the CSG tree.  

        Parameters
        ----------
        * root_universe :  
            the root Universe of the CSG tree.  

        """
        val = _openmoc.Geometry_setRootUniverse(self, root_universe)

          # SWIG 3
        if 'root_universe' in locals():
          root_universe = locals()['root_universe']
        elif 'args' in locals() and 'root_universe' in locals()['args']:
          root_universe = locals()['args']['root_universe']
        elif 'kwargs' in locals() and 'root_universe' in locals()['kwargs']:
          root_universe = locals()['kwargs']['root_universe']

        # SWIG 2
        else:
          root_universe = locals()['args'][0]

        root_universe.thisown = False


        return val


    def getCmfd(self):
        """

        getCmfd() -> Cmfd *  

        Returns a pointer to the CMFD object.  

        Returns
        -------
        A pointer to the CMFD object  

        """
        return _openmoc.Geometry_getCmfd(self)


    def getFSRsToKeys(self):
        """

        getFSRsToKeys() -> std::vector< std::string > &  

        Returns the vector that maps FSR IDs to FSR key hashes.  

        Returns
        -------
        _FSR_keys_map map of FSR keys to FSR IDs  

        """
        return _openmoc.Geometry_getFSRsToKeys(self)


    def getFSRId(self, coords):
        """

        getFSRId(LocalCoords *coords) -> int  

        Return the ID of the flat source region that a given LocalCoords object resides within.  

        Parameters
        ----------
        * coords :  
            a LocalCoords object pointer  

        Returns
        -------
        the FSR ID for a given LocalCoords object  

        """
        return _openmoc.Geometry_getFSRId(self, coords)


    def getFSRPoint(self, fsr_id):
        """

        getFSRPoint(int fsr_id) -> Point *  

        Return the characteristic point for a given FSR ID.  

        Parameters
        ----------
        * fsr_id :  
            the FSR ID  

        Returns
        -------
        the FSR's characteristic point  

        """
        return _openmoc.Geometry_getFSRPoint(self, fsr_id)


    def getFSRCentroid(self, fsr_id):
        """

        getFSRCentroid(int fsr_id) -> Point *  

        Return the centroid for a given FSR ID.  

        Parameters
        ----------
        * fsr_id :  
            the FSR ID  

        Returns
        -------
        the FSR's centroid  

        """
        return _openmoc.Geometry_getFSRCentroid(self, fsr_id)


    def getFSRKey(self, coords):
        """

        getFSRKey(LocalCoords *coords) -> std::string  

        Generate a string FSR "key" that identifies an FSR by its unique hierarchical
        lattice/universe/cell structure.  

        Since not all FSRs will reside on the absolute lowest universe level and Cells might
        overlap other cells, it is important to have a method for uniquely identifying FSRs. This
        method creates a unique FSR key by constructing a structured string that describes the
        hierarchy of lattices/universes/cells.  

        Parameters
        ----------
        * coords :  
            a LocalCoords object pointer  

        Returns
        -------
        the FSR key  

        """
        return _openmoc.Geometry_getFSRKey(self, coords)


    def getFSRKeysMap(self):
        """

        getFSRKeysMap() -> ParallelHashMap< std::string, fsr_data * > &  

        Returns a pointer to the map that maps FSR keys to FSR IDs.  

        Returns
        -------
        pointer to _FSR_keys_map map of FSR keys to FSR IDs  

        """
        return _openmoc.Geometry_getFSRKeysMap(self)


    def matchFSRstoCells(self):
        return _openmoc.Geometry_matchFSRstoCells(self)

    def getMapFSRstoCells(self):
        return _openmoc.Geometry_getMapFSRstoCells(self)

    def setCmfd(self, cmfd):
        """

        setCmfd(Cmfd *cmfd)  

        Sets the pointer to a CMFD object used for acceleration.  

        Parameters
        ----------
        * cmfd :  
            a pointer to the CMFD object  

        """
        val = _openmoc.Geometry_setCmfd(self, cmfd)

          # SWIG 3
        if 'cmfd' in locals():
          cmfd = locals()['cmfd']
        elif 'args' in locals() and 'cmfd' in locals()['args']:
          cmfd = locals()['args']['cmfd']
        elif 'kwargs' in locals() and 'cmfd' in locals()['kwargs']:
          cmfd = locals()['kwargs']['cmfd']

        # SWIG 2
        else:
          cmfd = locals()['args'][0]

        cmfd.thisown = False


        return val


    def findCellContainingCoords(self, coords):
        """

        findCellContainingCoords(LocalCoords *coords) -> Cell *  

        Find the Cell that this LocalCoords object is in at the lowest level of the nested
        Universe hierarchy.  

        This method assumes that the LocalCoords has been initialized with coordinates and a
        Universe ID. The method will recursively find the Cell on the lowest level of the nested
        Universe hierarchy by building a linked list of LocalCoords from the LocalCoord passed in
        as an argument down to the lowest level Cell found. In the process it will set the
        coordinates at each level of the hierarchy for each LocalCoord in the linked list for the
        Lattice or Universe that it is in. If the LocalCoords is outside the bounds of the
        Geometry or on the boundaries this method will return NULL; otherwise it will return a
        pointer to the Cell that is found by the recursive Geometry::findCell(...) method.  

        Parameters
        ----------
        * coords :  
            pointer to a LocalCoords object  

        Returns
        -------
        returns a pointer to a Cell if found, NULL if no Cell found  

        """
        return _openmoc.Geometry_findCellContainingCoords(self, coords)


    def findFSRMaterial(self, fsr_id):
        """

        findFSRMaterial(int fsr_id) -> Material *  

        Find the Material for a flat source region ID.  

        Parameters
        ----------
        * fsr_id :  
            a FSR id  

        Returns
        -------
        a pointer to the Material that this FSR is in  

        """
        return _openmoc.Geometry_findFSRMaterial(self, fsr_id)


    def findFSRId(self, coords):
        """

        findFSRId(LocalCoords *coords) -> int  

        Find and return the ID of the flat source region that a given LocalCoords object resides
        within.  

        Parameters
        ----------
        * coords :  
            a LocalCoords object pointer  

        Returns
        -------
        the FSR ID for a given LocalCoords object  

        """
        return _openmoc.Geometry_findFSRId(self, coords)


    def findCellContainingFSR(self, fsr_id):
        """

        findCellContainingFSR(int fsr_id) -> Cell *  

        Finds the Cell containing a given fsr ID.  

        Parameters
        ----------
        * fsr_id :  
            an FSR ID.  

        """
        return _openmoc.Geometry_findCellContainingFSR(self, fsr_id)


    def subdivideCells(self):
        """

        subdivideCells()  

        Subdivides all Cells in the Geometry into rings and angular sectors aligned with the
        z-axis.  

        This method is called by the Geometry::initializeFSRs() method but may also be called by
        the user in Python if needed:  



        """
        return _openmoc.Geometry_subdivideCells(self)


    def initializeFSRs(self, neighbor_cells=False):
        """

        initializeFSRs(bool neighbor_cells=false)  

        Compute the number of flat source regions in the Geometry and initialize CMFD.  

        This method is intended to be called by the user before initiating source iteration. This
        method first subdivides all Cells by calling the Geometry::subdivideCells() method. Then
        it initializes the CMFD object. neighbor_cells whether to use neighbor cell optimizations  

        """
        return _openmoc.Geometry_initializeFSRs(self, neighbor_cells)


    def segmentize(self, track):
        """

        segmentize(Track *track)  

        This method performs ray tracing to create Track segments within each flat source region
        in the Geometry.  

        This method starts at the beginning of a Track and finds successive intersection points
        with FSRs as the Track crosses through the Geometry and creates segment structs and adds
        them to the Track.  

        Parameters
        ----------
        * track :  
            a pointer to a track to segmentize  

        """
        return _openmoc.Geometry_segmentize(self, track)


    def computeFissionability(self, univ=None):
        """

        computeFissionability(Universe *univ=NULL)  

        Determines the fissionability of each Universe within this Geometry.  

        A Universe is determined fissionable if it contains a Cell filled by a Material with a
        non-zero fission cross-section. Note that this method recurses through all Universes at
        each level in the nested Universe hierarchy. Users should only call this method without a
        parameter (the default) from Python as follows to ensure that the recursion starts from
        the uppermost Universe level:  


        Parameters
        ----------
        * univ :  
            the Universe of interest (default is NULL)  

        """
        return _openmoc.Geometry_computeFissionability(self, univ)


    def getSpatialDataOnGrid(self, *args, **kwargs):
        """

        getSpatialDataOnGrid(std::vector< double > grid_x, std::vector< double > grid_y, double
            zcoord, const char *domain_type="material") -> std::vector< int >  

        Get the material, cell or FSR IDs on a 2D spatial grid.  

        This is a helper method for the openmoc.plotter module. This method may also be called by
        the user in Python if needed. A user must initialize NumPy arrays with the x and y grid
        coordinates input to this function. This function then fills a NumPy array with the domain
        IDs for each coordinate. An example of how this function might be called in Python is as
        follows:  


        Parameters
        ----------
        * grid_x :  
            a NumPy array or list of the x-coordinates  
        * num_x :  
            the number of x-coordinates in the grid  
        * grid_y :  
            a NumPy array or list of the y-coordinates  
        * num_y :  
            the number of y-coordinates in the grid  
        * zcoord :  
            the z-coordinate to use to find the domain IDs  
        * domain_type :  
            the type of domain ('fsr', 'material', 'cell')  

        Returns
        -------
        a NumPy array or list of the domain IDs  

        """
        return _openmoc.Geometry_getSpatialDataOnGrid(self, *args, **kwargs)


    def toString(self):
        """

        toString() -> std::string  

        Converts this Geometry's attributes to a character array.  

        This method calls the toString() method for all Surfaces, Cells, Universes and Lattices
        contained by the Geometry. Since this routine provides the metadata used by the
        TrackGenerator to discriminate between geometries when exporting / importing binary track
        files.  

        Returns
        -------
        a character array of this Geometry's class attributes  

        Add string data for all Cells  

        Add string data for the Surfaces in this Cell  

        Add string data for all Universes  

        """
        return _openmoc.Geometry_toString(self)


    def printString(self):
        """

        printString()  

        Prints a string representation of all of the Geometry's attributes to the console.  

        This method calls the printString() method for all Materials, Surfaces, Cell, Universes
        and Lattices contained by the Geometry.  

        """
        return _openmoc.Geometry_printString(self)


    def initializeCmfd(self):
        """

        initializeCmfd()  

        This is a method that initializes the CMFD Lattice and sets CMFD parameters.  

        """
        return _openmoc.Geometry_initializeCmfd(self)


    def withinBounds(self, coords):
        """

        withinBounds(LocalCoords *coords) -> bool  

        Determins whether a point is within the bounding box of the geometry.  

        Parameters
        ----------
        * coords :  
            a populated LocalCoords linked list  

        Returns
        -------
        boolean indicating whether the coords is within the geometry  

        """
        return _openmoc.Geometry_withinBounds(self, coords)

Geometry_swigregister = _openmoc.Geometry_swigregister
Geometry_swigregister(Geometry)


_openmoc.UNIV_swigconstant(_openmoc)
UNIV = _openmoc.UNIV

_openmoc.LAT_swigconstant(_openmoc)
LAT = _openmoc.LAT
class LocalCoords(_object):
    """


    The LocalCoords represents a set of local coordinates on some level of nested Universes
    making up the geometry.  

    C++ includes: openmoc/src/host/LocalCoords.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalCoords, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocalCoords, name)
    __repr__ = _swig_repr

    def __init__(self, x, y, z):
        """

        LocalCoords(double x, double y, double z)  

        Constructor sets the x and y coordinates.  

        Parameters
        ----------
        * x :  
            the x-coordinate  
        * y :  
            the y-coordinate  

        """
        this = _openmoc.new_LocalCoords(x, y, z)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_LocalCoords
    __del__ = lambda self: None

    def getType(self):
        """

        getType() -> coordType  

        Return the level (UNIV or LAT) of this LocalCoords.  

        Returns
        -------
        the nested Universe level (UNIV or LAT)  

        """
        return _openmoc.LocalCoords_getType(self)


    def getUniverse(self):
        """

        getUniverse() const  -> Universe *  

        Return the Universe within which this LocalCoords resides.  

        Returns
        -------
        the Universe  

        """
        return _openmoc.LocalCoords_getUniverse(self)


    def getCell(self):
        """

        getCell() const  -> Cell *  

        Return the Cell within which this LocalCoords resides.  

        Returns
        -------
        the Cell  

        """
        return _openmoc.LocalCoords_getCell(self)


    def getLattice(self):
        """

        getLattice() const  -> Lattice *  

        Return the Lattice within which this LocalCoords resides.  

        Returns
        -------
        the Lattice  

        """
        return _openmoc.LocalCoords_getLattice(self)


    def getLatticeX(self):
        """

        getLatticeX() const  -> int  

        Return the first index of the Lattice cell within which this LocalCoords resides.  

        Returns
        -------
        the first Lattice cell index  

        """
        return _openmoc.LocalCoords_getLatticeX(self)


    def getLatticeY(self):
        """

        getLatticeY() const  -> int  

        Return the second index of the Lattice cell within which this LocalCoords resides.  

        Returns
        -------
        the second Lattice cell index  

        """
        return _openmoc.LocalCoords_getLatticeY(self)


    def getLatticeZ(self):
        """

        getLatticeZ() const  -> int  

        Return the third index of the Lattice cell within which this LocalCoords resides.  

        Returns
        -------
        the third Lattice cell index  

        """
        return _openmoc.LocalCoords_getLatticeZ(self)


    def getX(self):
        """

        getX() const  -> double  

        Returns the x-coordinate for this LocalCoords location.  

        Returns
        -------
        the x-coordinate of this LocalCoords location  

        """
        return _openmoc.LocalCoords_getX(self)


    def getY(self):
        """

        getY() const  -> double  

        Returns the y-coordinate for this LocalCoords location.  

        Returns
        -------
        the y-coordinate of this LocalCoords location  

        """
        return _openmoc.LocalCoords_getY(self)


    def getZ(self):
        """

        getZ() const  -> double  

        Returns the z-coordinate for this LocalCoords location.  

        Returns
        -------
        the z-coordinate of this LocalCoords location  

        """
        return _openmoc.LocalCoords_getZ(self)


    def getPhi(self):
        """

        getPhi() const  -> double  

        Returns the direction angle in radians with respect to the x-axis.  

        Returns
        -------
        the direction angle in radians  

        """
        return _openmoc.LocalCoords_getPhi(self)


    def getPoint(self):
        """

        getPoint() -> Point *  

        Returns a pointer to the Point containing the coordinates for this LocalCoord.  

        Returns
        -------
        pointer to the Point containing the x and y coordinates  

        """
        return _openmoc.LocalCoords_getPoint(self)


    def getNext(self):
        """

        getNext() const  -> LocalCoords *  

        Return a pointer to the LocalCoord at the next lower nested Universe level if one exists.  

        Returns
        -------
        pointer to the next LocalCoord  

        """
        return _openmoc.LocalCoords_getNext(self)


    def getPrev(self):
        """

        getPrev() const  -> LocalCoords *  

        Return a pointer to the LocalCoord at the next higher nested Universe level if one exists.  

        Returns
        -------
        pointer to the previous LocalCoord  

        """
        return _openmoc.LocalCoords_getPrev(self)


    def setType(self, type):
        """

        setType(coordType type)  

        Set the type of LocalCoords (UNIV or LAT).  

        Parameters
        ----------
        * type :  
            the type for LocalCoords (UNIV or LAT)  

        """
        return _openmoc.LocalCoords_setType(self, type)


    def setUniverse(self, universe):
        """

        setUniverse(Universe *universe)  

        Set the Universe within which this LocalCoords resides.  

        Parameters
        ----------
        * universe :  
            the Universe  

        """
        return _openmoc.LocalCoords_setUniverse(self, universe)


    def setCell(self, cell):
        """

        setCell(Cell *cell)  

        Set the Cell within which this LocalCoords resides.  

        Parameters
        ----------
        * cell :  
            the Cell  

        """
        return _openmoc.LocalCoords_setCell(self, cell)


    def setLattice(self, lattice):
        """

        setLattice(Lattice *lattice)  

        Sets the Lattice within which this LocalCoords resides.  

        Parameters
        ----------
        * lattice :  
            the Lattice  

        """
        return _openmoc.LocalCoords_setLattice(self, lattice)


    def setLatticeX(self, lattice_x):
        """

        setLatticeX(int lattice_x)  

        Sets the x index for the Lattice cell within which this LocalCoords resides.  

        Parameters
        ----------
        * lattice_x :  
            the x Lattice cell index  

        """
        return _openmoc.LocalCoords_setLatticeX(self, lattice_x)


    def setLatticeY(self, lattice_y):
        """

        setLatticeY(int lattice_y)  

        Sets the y index for the Lattice cell within which this LocalCoords resides.  

        Parameters
        ----------
        * lattice_y :  
            the y Lattice cell index  

        """
        return _openmoc.LocalCoords_setLatticeY(self, lattice_y)


    def setLatticeZ(self, lattice_z):
        """

        setLatticeZ(int lattice_z)  

        Sets the z index for the Lattice cell within which this LocalCoords resides.  

        Parameters
        ----------
        * lattice_z :  
            the z Lattice cell index  

        """
        return _openmoc.LocalCoords_setLatticeZ(self, lattice_z)


    def setX(self, x):
        """

        setX(double x)  

        Set the x-coordinate for this LocalCoords.  

        Parameters
        ----------
        * x :  
            the x-coordinate  

        """
        return _openmoc.LocalCoords_setX(self, x)


    def setY(self, y):
        """

        setY(double y)  

        Set the y-coordinate for this Localcoords.  

        Parameters
        ----------
        * y :  
            the y-coordinate  

        """
        return _openmoc.LocalCoords_setY(self, y)


    def setZ(self, z):
        """

        setZ(double z)  

        Set the z-coordinate for this Localcoords.  

        Parameters
        ----------
        * z :  
            the z-coordinate  

        """
        return _openmoc.LocalCoords_setZ(self, z)


    def setPhi(self, phi):
        """

        setPhi(double phi)  

        Set the direction angle in radians for this LocalCoords.  

        Parameters
        ----------
        * angle :  
            the direction angle in radians  

        """
        return _openmoc.LocalCoords_setPhi(self, phi)


    def incrementPhi(self, phi):
        """

        incrementPhi(double phi)  

        Increment the direction angle in radians for this LocalCoords.  

        Parameters
        ----------
        * phi :  
            the incremental direction angle in radians  

        """
        return _openmoc.LocalCoords_incrementPhi(self, phi)


    def setNext(self, next):
        """

        setNext(LocalCoords *next)  

        Sets the pointer to the LocalCoords on the next lower nested Universe level.  

        Parameters
        ----------
        * next :  
            pointer to the next LocalCoords  

        """
        return _openmoc.LocalCoords_setNext(self, next)


    def setPrev(self, coords):
        """

        setPrev(LocalCoords *coords)  

        Sets the pointer to the LocalCoords on the next higher nested Universe level.  

        Parameters
        ----------
        * prev :  
            pointer to the previous LocalCoords  

        """
        return _openmoc.LocalCoords_setPrev(self, coords)


    def getLowestLevel(self):
        """

        getLowestLevel() -> LocalCoords *  

        Find and return the last LocalCoords in the linked list which represents the local
        coordinates on the lowest level of a geometry of nested universes.  

        Traverses a linked list of LocalCoords to find the one at the lowest nested Universe
        level.  

        Returns
        -------
        a pointer to the last LocalCoords object in the list  

        """
        return _openmoc.LocalCoords_getLowestLevel(self)


    def getHighestLevel(self):
        """

        getHighestLevel() -> LocalCoords *  

        Find and return the first LocalCoords in the linked list which represents the local
        coordinates on the highest level of a geometry of nested universes.  

        Traverses a linked list of LocalCoords to find the one at the highest nested Universe
        level.  

        Returns
        -------
        a pointer to the first LocalCoords object in the list  

        """
        return _openmoc.LocalCoords_getHighestLevel(self)


    def adjustCoords(self, delta):
        """

        adjustCoords(double delta)  

        Translate all of the x,y coordinates for each LocalCoords object in the linked list.  

        This method will traverse the entire linked list and apply the translation to each
        element.  

        Parameters
        ----------
        * delta :  
            amount we wish to move the point by  

        """
        return _openmoc.LocalCoords_adjustCoords(self, delta)


    def updateMostLocal(self, point):
        """

        updateMostLocal(Point *point)  

        Update the last element in the linked list (the one at the lowest level of nested
        Universes) to have the same coordinates as a given point.  

        Parameters
        ----------
        * point :  
            a pointer to a point of interest  

        """
        return _openmoc.LocalCoords_updateMostLocal(self, point)


    def prune(self):
        """

        prune()  

        Removes and frees memory for all LocalCoords beyond this one in the linked list.  

        """
        return _openmoc.LocalCoords_prune(self)


    def copyCoords(self, coords):
        """

        copyCoords(LocalCoords *coords)  

        Copies a LocalCoords' values to this one. details Given a pointer to a LocalCoords, it
        first prunes it and then creates a copy of the linked list of LocalCoords in the linked
        list below this one to give to the input LocalCoords.  

        Parameters
        ----------
        * coords :  
            a pointer to the LocalCoords to give the linked list copy to  

        """
        return _openmoc.LocalCoords_copyCoords(self, coords)


    def toString(self):
        """

        toString() -> std::string  

        Converts this LocalCoords's attributes to a character array representation.  

        Returns
        -------
        a character array of the LocalCoord's attributes  

        """
        return _openmoc.LocalCoords_toString(self)

LocalCoords_swigregister = _openmoc.LocalCoords_swigregister
LocalCoords_swigregister(LocalCoords)


_openmoc.DEBUG_swigconstant(_openmoc)
DEBUG = _openmoc.DEBUG

_openmoc.INFO_swigconstant(_openmoc)
INFO = _openmoc.INFO

_openmoc.NORMAL_swigconstant(_openmoc)
NORMAL = _openmoc.NORMAL

_openmoc.SEPARATOR_swigconstant(_openmoc)
SEPARATOR = _openmoc.SEPARATOR

_openmoc.HEADER_swigconstant(_openmoc)
HEADER = _openmoc.HEADER

_openmoc.TITLE_swigconstant(_openmoc)
TITLE = _openmoc.TITLE

_openmoc.WARNING_swigconstant(_openmoc)
WARNING = _openmoc.WARNING

_openmoc.CRITICAL_swigconstant(_openmoc)
CRITICAL = _openmoc.CRITICAL

_openmoc.RESULT_swigconstant(_openmoc)
RESULT = _openmoc.RESULT

_openmoc.ERROR_swigconstant(_openmoc)
ERROR = _openmoc.ERROR

def set_err(msg):
    """

    set_err(const char *msg)  

    A function stub used to convert C++ exceptions into Python exceptions through SWIG.  

    This method is not defined in the C++ source. It is defined in the SWIG inteface files
    (i.e., openmoc/openmoc.i)  

    Parameters
    ----------
    * msg :  
        a character array for the exception message  

    """
    return _openmoc.set_err(msg)

def initialize_logger():
    """

    initialize_logger()  

    Initializes the logger for use.  

    This should be immediately called when the logger is imported into Python and before any
    of its other routines are called. The routine initializes an OpenMP mutual exclusion lock
    which is used to preclude race conditions from occurring when an ERROR message is reported
    and program execution is terminated.  

    """
    return _openmoc.initialize_logger()

def set_output_directory(directory):
    """

    set_output_directory(char *directory)  

    Sets the output directory for log files.  

    If the directory does not exist, it creates it for the user.  

    Parameters
    ----------
    * directory :  
        a character array for the log file directory  

    """
    return _openmoc.set_output_directory(directory)

def get_output_directory():
    """

    get_output_directory() -> const char *  

    Returns the output directory for log files.  

    Returns
    -------
    a character array for the log file directory  

    """
    return _openmoc.get_output_directory()

def set_log_filename(filename):
    """

    set_log_filename(char *filename)  

    Sets the name for the log file.  

    Parameters
    ----------
    * filename :  
        a character array for log filename  

    """
    return _openmoc.set_log_filename(filename)

def get_log_filename():
    """

    get_log_filename() -> const char *  

    Returns the log filename.  

    Returns
    -------
    a character array for the log filename  

    """
    return _openmoc.get_log_filename()

def set_separator_character(c):
    """

    set_separator_character(char c)  

    Sets the character to be used when printing SEPARATOR log messages.  

    Parameters
    ----------
    * c :  
        the character for SEPARATOR log messages  

    """
    return _openmoc.set_separator_character(c)

def get_separator_character():
    """

    get_separator_character() -> char  

    Returns the character used to format SEPARATOR log messages.  

    Returns
    -------
    the character used for SEPARATOR log messages  

    """
    return _openmoc.get_separator_character()

def set_header_character(c):
    """

    set_header_character(char c)  

    Sets the character to be used when printing HEADER log messages.  

    Parameters
    ----------
    * c :  
        the character for HEADER log messages  

    """
    return _openmoc.set_header_character(c)

def get_header_character():
    """

    get_header_character() -> char  

    Returns the character used to format HEADER type log messages.  

    Returns
    -------
    the character used for HEADER type log messages  

    """
    return _openmoc.get_header_character()

def set_title_character(c):
    """

    set_title_character(char c)  

    Sets the character to be used when printing TITLE log messages.  

    Parameters
    ----------
    * c :  
        the character for TITLE log messages  

    """
    return _openmoc.set_title_character(c)

def get_title_character():
    """

    get_title_character() -> char  

    Returns the character used to format TITLE log messages.  

    Returns
    -------
    the character used for TITLE log messages  

    """
    return _openmoc.get_title_character()

def set_line_length(length):
    """

    set_line_length(int length)  

    Sets the maximum line length for log messages.  

    Messages longer than this amount will be broken up into multiline messages.  

    Parameters
    ----------
    * length :  
        the maximum log message line length in characters  

    """
    return _openmoc.set_line_length(length)

def set_log_level(new_level):
    """

    set_log_level(const char *new_level)  

    Sets the minimum log message level which will be printed to the console and to the log
    file.  

    Parameters
    ----------
    * new_level :  
        the minimum logging level as a character array  

    """
    return _openmoc.set_log_level(new_level)

def get_log_level():
    """

    get_log_level() -> const char *  

    Return the minimum level for log messages printed to the screen.  

    Returns
    -------
    the minimum level for log messages  

    """
    return _openmoc.get_log_level()

def log_printf(level, format):
    """

    log_printf(logLevel level, const char *format,...)  

    Print a formatted message to the console.  

    If the logging level is ERROR, this function will throw a runtime exception  

    Parameters
    ----------
    * level :  
        the logging level for this message  
    * format :  
        variable list of C++ formatted arguments  

    """
    return _openmoc.log_printf(level, format)

def create_multiline_msg(level, message):
    """

    create_multiline_msg(std::string level, std::string message) -> std::string  

    Breaks up a message which is too long for a single line into a multiline message.  

    This is an internal function which is called by log_printf and should not be called
    directly by the user.  

    Parameters
    ----------
    * level :  
        a string containing log level prefix  
    * message :  
        a string containing the log message  

    Returns
    -------
    a string with a formatted multiline message  

    """
    return _openmoc.create_multiline_msg(level, message)

def material_id():
    """

    material_id() -> int  

    Returns an auto-generated unique Material ID.  

    This method is intended as a utility method for user's writing OpenMOC input files. The
    method makes use of a static Material ID which is incremented each time the method is
    called to enable unique generation of monotonically increasing IDs. The method's first ID
    begins at 10000. Hence, user-defined material IDs greater than or equal to 10000 is
    prohibited.  

    """
    return _openmoc.material_id()

def reset_material_id():
    """

    reset_material_id()  

    Resets the auto-generated unique Material ID counter to 10000.  

    """
    return _openmoc.reset_material_id()

def maximize_material_id(material_id):
    """

    maximize_material_id(int material_id)  

    Maximize the auto-generated unique Material ID counter.  

    This method updates the auto-generated unique Material ID counter if the input parameter
    is greater than the present value. This is useful for the OpenMC compatibility module to
    ensure that the auto-generated Material IDs do not collide with those created in OpenMC.  

    Parameters
    ----------
    * material_id :  
        the id assigned to the auto-generated counter  

    """
    return _openmoc.maximize_material_id(material_id)
class Material(_object):
    """


    The Material class represents a unique material and its relevant nuclear data (i.e.,
    multigroup cross-sections) for neutron transport.  

    C++ includes: src/Material.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Material, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Material, name)
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """

        Material(int id=0, const char *name="")  

        Constructor sets the ID and unique ID for the Material.  

        Parameters
        ----------
        * id :  
            the user-specified optional Material ID  
        * name :  
            the user-specified optional Material name  

        """
        this = _openmoc.new_Material(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Material
    __del__ = lambda self: None

    def getId(self):
        """

        getId() const  -> int  

        Return the Material's user-defined ID.  

        Returns
        -------
        the Material's user-defined ID  

        """
        return _openmoc.Material_getId(self)


    def getName(self):
        """

        getName() const  -> char *  

        Return the user-defined name of the Material.  

        Returns
        -------
        the Material name  

        """
        return _openmoc.Material_getName(self)


    def getVolume(self):
        """

        getVolume() -> double  

        Return the aggregate volume/area of all instances of this Material.  

        The volume/area of the Material is computed from track segments which overlap this
        Material during track generation.  

        Returns
        -------
        the volume/area of the Material  

        """
        return _openmoc.Material_getVolume(self)


    def getNumInstances(self):
        """

        getNumInstances() -> int  

        Return the number of instances of this Material in the Geometry.  

        The number of instances of this Material in the Geometry is determined during track
        generation.  

        Returns
        -------
        the number of material instances  

        """
        return _openmoc.Material_getNumInstances(self)


    def getNumEnergyGroups(self):
        """

        getNumEnergyGroups() const  -> int  

        Returns the number of energy groups for this Material's nuclear data.  

        Returns
        -------
        the number of energy groups  

        """
        return _openmoc.Material_getNumEnergyGroups(self)


    def getSigmaT(self):
        """

        getSigmaT() -> FP_PRECISION *  

        Return the array of the Material's total cross-sections.  

        Returns
        -------
        the pointer to the Material's array of total cross-sections  

        """
        return _openmoc.Material_getSigmaT(self)


    def getSigmaS(self):
        """

        getSigmaS() -> FP_PRECISION *  

        Return the array of the Material's scattering cross-section matrix.  

        Returns
        -------
        the pointer to the Material's array of scattering cross-sections  

        """
        return _openmoc.Material_getSigmaS(self)


    def getSigmaF(self):
        """

        getSigmaF() -> FP_PRECISION *  

        Return the array of the Material's fission cross-sections.  

        Returns
        -------
        the pointer to the Material's array of fission cross-sections  

        """
        return _openmoc.Material_getSigmaF(self)


    def getNuSigmaF(self):
        """

        getNuSigmaF() -> FP_PRECISION *  

        Return the array of the Material's fission cross-sections multiplied by nu $ \nu $.  

        Returns
        -------
        the pointer to the Material's array of fission cross-sections multiplied by nu $ \nu $  

        """
        return _openmoc.Material_getNuSigmaF(self)


    def getChi(self):
        """

        getChi() -> FP_PRECISION *  

        Return the array of the Material's chi $ \chi $.  

        Returns
        -------
        the pointer to the Material's array of chi $ \chi $ values  

        """
        return _openmoc.Material_getChi(self)


    def getFissionMatrix(self):
        """

        getFissionMatrix() -> FP_PRECISION *  

        Return the array of the Material's fission matrix.  

        Returns
        -------
        the pointer to the Material's fission matrix array  

        """
        return _openmoc.Material_getFissionMatrix(self)


    def getSigmaTByGroup(self, group):
        """

        getSigmaTByGroup(int group) -> FP_PRECISION  

        Get the Material's total cross section for some energy group.  

        Parameters
        ----------
        * group :  
            the energy group  

        Returns
        -------
        the total cross section  

        """
        return _openmoc.Material_getSigmaTByGroup(self, group)


    def getSigmaSByGroup(self, origin, destination):
        """

        getSigmaSByGroup(int origin, int destination) -> FP_PRECISION  

        Get the Material's scattering cross section for some energy group.  

        Parameters
        ----------
        * origin :  
            the incoming energy group  
        * destination :  
            the outgoing energy group  

        Returns
        -------
        the scattering cross section  

        """
        return _openmoc.Material_getSigmaSByGroup(self, origin, destination)


    def getSigmaFByGroup(self, group):
        """

        getSigmaFByGroup(int group) -> FP_PRECISION  

        Get the Material's fission cross section for some energy group.  

        Parameters
        ----------
        * group :  
            the energy group  

        Returns
        -------
        the fission cross section  

        """
        return _openmoc.Material_getSigmaFByGroup(self, group)


    def getNuSigmaFByGroup(self, group):
        """

        getNuSigmaFByGroup(int group) -> FP_PRECISION  

        Get the Material's nu-fission cross section for some energy group.  

        Parameters
        ----------
        * group :  
            the energy group  

        Returns
        -------
        the nu-fission cross section  

        """
        return _openmoc.Material_getNuSigmaFByGroup(self, group)


    def getChiByGroup(self, group):
        """

        getChiByGroup(int group) -> FP_PRECISION  

        Get the Material's fission spectrum for some energy group.  

        Parameters
        ----------
        * group :  
            the energy group  

        Returns
        -------
        the fission spectrum  

        """
        return _openmoc.Material_getChiByGroup(self, group)


    def getFissionMatrixByGroup(self, origin, destination):
        """

        getFissionMatrixByGroup(int origin, int destination) -> FP_PRECISION  

        Get the Material's fission matrix for some energy group.  

        Parameters
        ----------
        * origin :  
            the incoming energy group $ E_{0} $  
        * destination :  
            the outgoing energy group $ E_{1} $  

        Returns
        -------
        the fission matrix entry $ \nu\Sigma_{f}(E_{0}) * \chi(E_{1})$  

        """
        return _openmoc.Material_getFissionMatrixByGroup(self, origin, destination)


    def isFissionable(self):
        """

        isFissionable() -> bool  

        Returns whether or not the Material contains a fissionable (non-zero) fission cross-
        section.  

        Returns
        -------
        true if fissionable, false otherwise  

        """
        return _openmoc.Material_isFissionable(self)


    def isDataAligned(self):
        """

        isDataAligned() -> bool  

        Returns true if the data is vector aligned, false otherwise (default).  

        Returns
        -------
        Whether or not the Material's data is vector aligned  

        """
        return _openmoc.Material_isDataAligned(self)


    def getNumVectorGroups(self):
        """

        getNumVectorGroups() -> int  

        Returns the rounded up number of energy groups to fill an integral number of vector
        lengths.  

        Returns
        -------
        The number of vector-aligned energy groups  

        """
        return _openmoc.Material_getNumVectorGroups(self)


    def setName(self, name):
        """

        setName(const char *name)  

        Sets the name of the Material.  

        Parameters
        ----------
        * name :  
            the Material name string  

        """
        return _openmoc.Material_setName(self, name)


    def setVolume(self, volume):
        """

        setVolume(double volume)  

        Set the volume/area of the Material.  

        Parameters
        ----------
        * volume :  
            the volume/area of the Material  

        """
        return _openmoc.Material_setVolume(self, volume)


    def incrementVolume(self, volume):
        """

        incrementVolume(double volume)  

        Increment the volume/area of the Material by some amount.  

        This routine is called by the TrackGenerator during track generation and segmentation.  

        Parameters
        ----------
        * volume :  
            the amount to increment the current volume by  

        """
        return _openmoc.Material_incrementVolume(self, volume)


    def setNumInstances(self, num_instances):
        """

        setNumInstances(int num_instances)  

        Set the number of instances of this Material.  

        Parameters
        ----------
        * num_instances :  
            the number of instances of this Material in the Geometry  

        """
        return _openmoc.Material_setNumInstances(self, num_instances)


    def incrementNumInstances(self):
        """

        incrementNumInstances()  

        Increment the number of instances of this Material.  

        This routine is called by the TrackGenerator during track generation and segmentation.  

        """
        return _openmoc.Material_incrementNumInstances(self)


    def setNumEnergyGroups(self, num_groups):
        """

        setNumEnergyGroups(const int num_groups)  

        Set the number of energy groups for this Material.  

        Parameters
        ----------
        * num_groups :  
            the number of energy groups.  

        """
        return _openmoc.Material_setNumEnergyGroups(self, num_groups)


    def setSigmaT(self, xs):
        """

        setSigmaT(double *xs, int num_groups)  

        Set the Material's array of total cross-sections.  

        This method is a helper function to allow OpenMOC users to assign the Material's nuclear
        data in Python. A user must initialize a NumPy array of the correct size (e.g., a float64
        array the length of the number of energy groups) as input to this function. This function
        then fills the NumPy array with the data values for the Material's total cross-sections.
        An example of how this function might be called in Python is as follows:  



                 NOTE: This routine will override an zero-valued cross-sections
                 (e.g., in void or gap regions) with a minimum value of 1E-10 to
                 void numerical issues in the MOC solver.  

        Parameters
        ----------
        * xs :  
            the array of total cross-sections  
        * num_groups :  
            the number of energy groups  

        """
        return _openmoc.Material_setSigmaT(self, xs)


    def setSigmaS(self, xs):
        """

        setSigmaS(double *xs, int num_groups)  

        Set the Material's 2D array of scattering cross-sections.  

        The array should be passed to OpenMOC as a 1D array in column-major order. This assumes
        the standard convention, where column index is the origin group and the row index is the
        destination group. That is, the array should be ordered as follows: 1 -> 1 1 -> 2 1 -> 3
        ... 2 -> 1 2 -> 2 ...  

        Note that if the scattering matrix is defined in NumPy by the standard convention,
        "flat" will put the matrix into row major order. Thus, one should transpose the matrix
        before flattening.  

        For cache efficiency, the transpose of the input is actually stored in OpenMOC.  

        This method is a helper function to allow OpenMOC users to assign the Material's nuclear
        data in Python. A user must initialize a NumPy array of the correct size (e.g., a float64
        array the length of the square of the number of energy groups) as input to this function.
        This function then fills the NumPy array with the data values for the Material's
        scattering cross-sections. An example of how this function might be called in Python is as
        follows:  


        Parameters
        ----------
        * xs :  
            the array of scattering cross-sections  
        * num_groups_squared :  
            the number of energy groups squared  

        """
        return _openmoc.Material_setSigmaS(self, xs)


    def setSigmaF(self, xs):
        """

        setSigmaF(double *xs, int num_groups)  

        Set the Material's array of fission cross-sections.  

        This method is a helper function to allow OpenMOC users to assign the Material's nuclear
        data in Python. A user must initialize a NumPy array of the correct size (e.g., a float64
        array the length of the number of energy groups) as input to this function. This function
        then fills the NumPy array with the data values for the Material's fission cross-sections.
        An example of how this function might be called in Python is as follows:  


        Parameters
        ----------
        * xs :  
            the array of fission cross-sections  
        * num_groups :  
            the number of energy groups  

        """
        return _openmoc.Material_setSigmaF(self, xs)


    def setNuSigmaF(self, xs):
        """

        setNuSigmaF(double *xs, int num_groups)  

        Set the Material's array of fission cross-sections multiplied by $ \nu $.  

        Parameters
        ----------
        * xs :  
            the array of fission cross-sections multiplied by nu $ \nu $  
        * num_groups :  
            the number of energy groups  

        """
        return _openmoc.Material_setNuSigmaF(self, xs)


    def setChi(self, xs):
        """

        setChi(double *xs, int num_groups)  

        Set the Material's array of chi $ \chi $ values.  

        This method is a helper function to allow OpenMOC users to assign the Material's nuclear
        data in Python. A user must initialize a NumPy array of the correct size (e.g., a float64
        array the length of the number of energy groups) as input to this function. This function
        then fills the NumPy array with the data values for the Material's chi distribution. An
        example of how this function might be called in Python is as follows:  


        Parameters
        ----------
        * xs :  
            the array of chi $ \chi $ values  
        * num_groups :  
            the number of energy groups  

        """
        return _openmoc.Material_setChi(self, xs)


    def setSigmaTByGroup(self, xs, group):
        """

        setSigmaTByGroup(double xs, int group)  

        Set the Material's total cross-section for some energy group.  

        Parameters
        ----------
        * xs :  
            the total cross-section  
        * group :  
            the energy group  

        """
        return _openmoc.Material_setSigmaTByGroup(self, xs, group)


    def setSigmaFByGroup(self, xs, group):
        """

        setSigmaFByGroup(double xs, int group)  

        Set the Material's fission cross-section for some energy group.  

        Parameters
        ----------
        * xs :  
            the fission cross-section  
        * group :  
            the energy group  

        """
        return _openmoc.Material_setSigmaFByGroup(self, xs, group)


    def setNuSigmaFByGroup(self, xs, group):
        """

        setNuSigmaFByGroup(double xs, int group)  

        Set the Material's fission cross-section multiplied by $ \nu $ for some energy group.  

        This method is a helper function to allow OpenMOC users to assign the Material's nuclear
        data in Python. A user must initialize a NumPy array of the correct size (e.g., a float64
        array the length of the number of energy groups) as input to this function. This function
        then fills the NumPy array with the data values for the Material's nu*fission cross-
        sections. An example of how this function might be called in Python is as follows:  


        Parameters
        ----------
        * xs :  
            the fission cross-section multiplied by nu $ \nu $  
        * group :  
            the energy group  

        """
        return _openmoc.Material_setNuSigmaFByGroup(self, xs, group)


    def setSigmaSByGroup(self, xs, origin, destination):
        """

        setSigmaSByGroup(double xs, int origin, int destination)  

        Set the Material's scattering cross-section for some energy group.  

        Parameters
        ----------
        * xs :  
            the scattering cross-section  
        * origin :  
            the column index in the scattering matrix  
        * destination :  
            the row index in the scattering matrix  

        """
        return _openmoc.Material_setSigmaSByGroup(self, xs, origin, destination)


    def setChiByGroup(self, xs, group):
        """

        setChiByGroup(double xs, int group)  

        Set the Material's chi value for some energy group.  

        Parameters
        ----------
        * xs :  
            the chi value ( $ \Chi $)  
        * group :  
            the energy group  

        """
        return _openmoc.Material_setChiByGroup(self, xs, group)


    def buildFissionMatrix(self):
        """

        buildFissionMatrix()  

        Builds the fission matrix from chi and the fission cross-section.  

        The fission matrix is constructed as the outer product of the chi and fission cross-
        section vectors. This routine is intended for internal use and is called by the Solver at
        runtime.  

        """
        return _openmoc.Material_buildFissionMatrix(self)


    def transposeProductionMatrices(self):
        """

        transposeProductionMatrices()  

        Transposes the scattering and fission matrices.  

        This routine is used by the Solver when performing adjoint flux caclulations.  

        """
        return _openmoc.Material_transposeProductionMatrices(self)


    def alignData(self):
        """

        alignData()  

        Reallocates the Material's cross-section data structures along word-aligned boundaries.  

        This method is used to assist with SIMD auto-vectorization of the MOC routines in the
        Solver classes. Rather than using the assigned number of energy groups, this method adds
        "dummy" energy groups such that the total number of groups is some multiple of
        VEC_LENGTH (typically 4, 8, or 16). As a result, the SIMD-vectorized Solver subclasses can
        break up loops over energy groups in such a way to "expose" the SIMD nature of the
        algorithm.  

        """
        return _openmoc.Material_alignData(self)


    def clone(self):
        """

        clone() -> Material *  

        Create a duplicate of the Material.  

        Returns
        -------
        a pointer to the clone  

        """
        return _openmoc.Material_clone(self)


    def copyFrom(self, material):
        return _openmoc.Material_copyFrom(self, material)

    def toString(self):
        """

        toString() -> std::string  

        Converts this Material's attributes to a character array representation.  

        The character array returned includes the user-defined ID, and each of the absorption,
        total, fission, nu multiplied by fission and scattering cross-sections and chi for all
        energy groups.  

        Returns
        -------
        character array of this Material's attributes  

        """
        return _openmoc.Material_toString(self)


    def printString(self):
        """

        printString()  

        Prints a string representation of all of the Material's attributes to the console.  

        """
        return _openmoc.Material_printString(self)

Material_swigregister = _openmoc.Material_swigregister
Material_swigregister(Material)

class Point(_object):
    """


    Class to represent a 3D point in space.  

    C++ includes: src/Point.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Point, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        Point()  

        Constructor initializes an empty Point.  

        """
        this = _openmoc.new_Point()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Point
    __del__ = lambda self: None

    def setCoords(self, x, y, z):
        """

        setCoords(const double x, const double y, const double z)  

        Initializes a Point with two-dimensional coordinates.  

        Parameters
        ----------
        * x :  
            x-coordinate  
        * y :  
            y-coordinate  

        """
        return _openmoc.Point_setCoords(self, x, y, z)


    def getX(self):
        """

        getX() const  -> double  

        Returns this Point's x-coordinate.  

        Returns
        -------
        the x-coordinate  

        """
        return _openmoc.Point_getX(self)


    def getY(self):
        """

        getY() const  -> double  

        Returns this Point's y-coordinate.  

        Returns
        -------
        the y-coordinate  

        """
        return _openmoc.Point_getY(self)


    def getZ(self):
        """

        getZ() const  -> double  

        Returns this Point's z-coordinate.  

        Returns
        -------
        the z-coordinate  

        """
        return _openmoc.Point_getZ(self)


    def setX(self, x):
        """

        setX(const double x)  

        Set the Point's x-coordinate.  

        Parameters
        ----------
        * x :  
            the new x-coordinate  

        """
        return _openmoc.Point_setX(self, x)


    def setY(self, y):
        """

        setY(const double y)  

        Set the Point's y-coordinate.  

        Parameters
        ----------
        * y :  
            the new y-coordinate  

        """
        return _openmoc.Point_setY(self, y)


    def setZ(self, z):
        """

        setZ(const double z)  

        Set the Point's z-coordinate.  

        Parameters
        ----------
        * z :  
            the new z-coordinate  

        """
        return _openmoc.Point_setZ(self, z)


    def distanceToPoint(self, point):
        """

        distanceToPoint(const Point *point) -> double  

        Compute the distance from this Point to another Point of interest.  

        Parameters
        ----------
        * point :  
            a pointer to the Point of interest  

        Returns
        -------
        distance to the Point of interest  

        """
        return _openmoc.Point_distanceToPoint(self, point)


    def toString(self):
        """

        toString() -> std::string  

        Converts this Point to a character representation of its attributes.  

        The character array includes the x-coordinate, y-coordinate, and z-coordinate  

        Returns
        -------
        a character array of this Point's attributes  

        """
        return _openmoc.Point_toString(self)

Point_swigregister = _openmoc.Point_swigregister
Point_swigregister(Point)


_openmoc.TABUCHI_YAMAMOTO_swigconstant(_openmoc)
TABUCHI_YAMAMOTO = _openmoc.TABUCHI_YAMAMOTO

_openmoc.LEONARD_swigconstant(_openmoc)
LEONARD = _openmoc.LEONARD

_openmoc.GAUSS_LEGENDRE_swigconstant(_openmoc)
GAUSS_LEGENDRE = _openmoc.GAUSS_LEGENDRE

_openmoc.EQUAL_WEIGHT_swigconstant(_openmoc)
EQUAL_WEIGHT = _openmoc.EQUAL_WEIGHT

_openmoc.EQUAL_ANGLE_swigconstant(_openmoc)
EQUAL_ANGLE = _openmoc.EQUAL_ANGLE
class Quadrature(_object):
    """


    The arbitrary quadrature parent class.  

    C++ includes: src/Quadrature.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Quadrature, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Quadrature, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        Quadrature()  

        Dummy constructor sets the default number of angles to zero.  

        """
        this = _openmoc.new_Quadrature()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Quadrature
    __del__ = lambda self: None

    def getNumPolarAngles(self):
        """

        getNumPolarAngles() const  -> int  

        Returns the number of polar angles.  

        Returns
        -------
        the number of polar angles  

        """
        return _openmoc.Quadrature_getNumPolarAngles(self)


    def getNumAzimAngles(self):
        """

        getNumAzimAngles() const  -> int  

        Returns the number of azimuthal angles.  

        Returns
        -------
        the number of azimuthal angles  

        """
        return _openmoc.Quadrature_getNumAzimAngles(self)


    def getSinTheta(self, azim, polar):
        """

        getSinTheta(int azim, int polar) -> FP_PRECISION  

        Returns the $ sin(\theta)$ value for a particular polar angle.  

        Parameters
        ----------
        * azim :  
            index of the azimthal angle of interest  
        * polar :  
            index of the polar angle of interest  

        Returns
        -------
        the value of $ \sin(\theta) $ for this azimuthal and polar angle  

        """
        return _openmoc.Quadrature_getSinTheta(self, azim, polar)


    def getTheta(self, azim, polar):
        """

        getTheta(int azim, int polar) -> double  

        Returns the polar angle in radians for a given azimuthal and polar angle index.  

        Parameters
        ----------
        * azim :  
            index of the azimthal angle of interest  
        * polar :  
            index of the polar angle of interest  

        Returns
        -------
        the value of the polar angle for this azimuthal and polar angle index  

        """
        return _openmoc.Quadrature_getTheta(self, azim, polar)


    def getPhi(self, azim):
        """

        getPhi(int azim) -> double  

        Returns the azimuthal angle value in radians.  

        Parameters
        ----------
        * azim :  
            index of the azimthal angle of interest  

        Returns
        -------
        the value of the azimuthal angle  

        """
        return _openmoc.Quadrature_getPhi(self, azim)


    def getAzimWeight(self, azim):
        """

        getAzimWeight(int azim) -> FP_PRECISION  

        Returns the azimuthal angle weight value for a particular azimuthal angle.  

        Parameters
        ----------
        * azim :  
            index of the azimuthal angle of interest  

        Returns
        -------
        the weight for an azimuthal angle  

        """
        return _openmoc.Quadrature_getAzimWeight(self, azim)


    def getPolarWeight(self, azim, polar):
        """

        getPolarWeight(int azim, int polar) -> FP_PRECISION  

        Returns the polar weight for a particular azimuthal and polar angle.  

        Parameters
        ----------
        * azim :  
            index of the azimthal angle of interest  
        * polar :  
            index of the polar angle of interest  

        Returns
        -------
        the value of the polar weight for this azimuthal and polar angle  

        """
        return _openmoc.Quadrature_getPolarWeight(self, azim, polar)


    def getWeight(self, azim, polar):
        """

        getWeight(int azim, int polar) -> FP_PRECISION  

        Returns the total weight for Tracks with the given azimuthal and polar indexes.  

        Angular weights are multiplied by Track spcings  

        Parameters
        ----------
        * azim :  
            index of the azimuthal angle of interest  
        * polar :  
            index of the polar angle of interest  

        Returns
        -------
        the total weight of each Track with the given indexes  

        """
        return _openmoc.Quadrature_getWeight(self, azim, polar)


    def getWeightInline(self, azim, polar):
        """

        getWeightInline(int azim, int polar) -> FP_PRECISION  

        Returns the total weight for Tracks with the given azimuthal and polar indexes without
        error checking and inlined.  

        Angular weights are multiplied by Track spcings  

        Parameters
        ----------
        * azim :  
            index of the azimuthal angle of interest  
        * polar :  
            index of the polar angle of interest  

        Returns
        -------
        the total weight of each Track with the given indexes  

        """
        return _openmoc.Quadrature_getWeightInline(self, azim, polar)


    def getSinThetas(self):
        """

        getSinThetas() -> FP_PRECISION **  

        Returns a pointer to the Quadrature's array of polar angle sines $ sin\theta_{p} $.  

        Returns
        -------
        a pointer to the array of $ sin\theta_{p} $  

        """
        return _openmoc.Quadrature_getSinThetas(self)


    def getThetas(self):
        """

        getThetas() -> double **  

        Returns a pointer to the Quadrature's array of polar angles $ \theta_{p} $.  

        Returns
        -------
        a pointer to the array of $ \theta_{p} $  

        """
        return _openmoc.Quadrature_getThetas(self)


    def getPhis(self):
        """

        getPhis() -> double *  

        Returns a pointer to the Quadrature's array of azimuthal angles $ \phi $.  

        Returns
        -------
        a pointer to the array of $ \phi $  

        """
        return _openmoc.Quadrature_getPhis(self)


    def getAzimWeights(self):
        """

        getAzimWeights() -> FP_PRECISION *  

        Returns a pointer to the Quadrature's array of azimuthal weights.  

        Returns
        -------
        a pointer to the azimuthal weights array  

        """
        return _openmoc.Quadrature_getAzimWeights(self)


    def getPolarWeights(self):
        """

        getPolarWeights() -> FP_PRECISION **  

        Returns a pointer to the Quadrature's array of polar weights.  

        Returns
        -------
        a pointer to the polar weights array  

        """
        return _openmoc.Quadrature_getPolarWeights(self)


    def getQuadratureType(self):
        """

        getQuadratureType() -> quadratureType  

        Returns the type of Quadrature created.  

        Returns
        -------
        The quadrature type  

        """
        return _openmoc.Quadrature_getQuadratureType(self)


    def getAzimSpacings(self):
        """

        getAzimSpacings() -> FP_PRECISION *  

        Returns an array of adjusted azimuthal spacings.  

        An array of azimuthal spacings after adjustment is returned, indexed by azimuthal angle  

        Returns
        -------
        the array of azimuthal spacings  

        """
        return _openmoc.Quadrature_getAzimSpacings(self)


    def getAzimSpacing(self, azim):
        """

        getAzimSpacing(int azim) -> FP_PRECISION  

        Returns the adjusted azimuthal spacing at the requested azimuthal angle index.  

        The aziumthal spacing depends on the azimuthal angle. This function returns the azimuthal
        spacing used at the desired azimuthal angle index.  

        Parameters
        ----------
        * azim :  
            the requested azimuthal angle index  

        Returns
        -------
        the requested azimuthal spacing  

        """
        return _openmoc.Quadrature_getAzimSpacing(self, azim)


    def setNumAzimAngles(self, num_azim):
        """

        setNumAzimAngles(const int num_azim)  

        Set the number of azimuthal angles to initialize.  

        Parameters
        ----------
        * num_azim :  
            the number of azimuthal angles  

        """
        return _openmoc.Quadrature_setNumAzimAngles(self, num_azim)


    def setNumPolarAngles(self, num_polar):
        """

        setNumPolarAngles(const int num_polar)  

        Set the number of polar angles to initialize.  

        Parameters
        ----------
        * num_polar :  
            the number of polar angles  

        """
        return _openmoc.Quadrature_setNumPolarAngles(self, num_polar)


    def setThetas(self, thetas, num_azim_times_polar):
        """

        setThetas(double *thetas, int num_azim_times_polar)  

        Sets the Quadrature's array of polar angles.  

        This method is a helper function to allow OpenMOC users to assign the Quadrature's polar
        angles in Python. A user must initialize a NumPy array of the correct size (e.g., a
        float64 array the length of the number of azimuthal times polar angles) as input to this
        function. This function then fills the Quadrature's polar angles with the given values. An
        example of how this function might be called in Python is as follows:  


        Parameters
        ----------
        * thetas :  
            the array of polar angle for each azimuthal/polar angle combination  
        * num_azim_times_polar :  
            the total number of angles (azimuthal x polar)  

        """
        return _openmoc.Quadrature_setThetas(self, thetas, num_azim_times_polar)


    def setPolarWeights(self, weights, num_azim_times_polar):
        """

        setPolarWeights(FP_PRECISION *weights, int num_azim_times_polar)  

        Set the Quadrature's array of polar weights.  

        This method is a helper function to allow OpenMOC users to assign the Quadrature's polar
        weights in Python. A user must initialize a NumPy array of the correct size (e.g., a
        float64 array the length of the number of azimuthal times polar angles) as input to this
        function. This function then fills the Quadrature's polar weights with the given values.
        An example of how this function might be called in Python is as follows:  


        Parameters
        ----------
        * weights :  
            The polar weights  
        * num_azim_times_polar :  
            the total number of angles in one octant (azimuthal x polar)  

        """
        return _openmoc.Quadrature_setPolarWeights(self, weights, num_azim_times_polar)


    def setTheta(self, theta, azim, polar):
        """

        setTheta(double theta, int azim, int polar)  

        Sets the polar angle for the given indexes.  

        Parameters
        ----------
        * theta :  
            the value in radians of the polar angle to be set  
        * azim :  
            the azimuthal index of the angle of interest  
        * polar :  
            the polar index of the angle of interest  

        """
        return _openmoc.Quadrature_setTheta(self, theta, azim, polar)


    def setPhi(self, phi, azim):
        """

        setPhi(double phi, int azim)  

        Sets the azimuthal angle for the given index.  

        Parameters
        ----------
        * phi :  
            the value in radians of the azimuthal angle to be set  
        * azim :  
            the azimuthal index  

        """
        return _openmoc.Quadrature_setPhi(self, phi, azim)


    def setAzimSpacing(self, spacing, azim):
        """

        setAzimSpacing(FP_PRECISION spacing, int azim)  

        Sets the azimuthal spacing for the given index.  

        Parameters
        ----------
        * spacing :  
            the spacing (cm) in the azimuthal direction to be set  
        * azim :  
            the azimuthal index  

        """
        return _openmoc.Quadrature_setAzimSpacing(self, spacing, azim)


    def setAzimWeight(self, weight, azim):
        """

        setAzimWeight(double weight, int azim)  

        Sets the azimuthal weight for the given index.  

        Parameters
        ----------
        * weight :  
            the weight of the azimuthal angle  
        * azim :  
            the azimuthal index  

        """
        return _openmoc.Quadrature_setAzimWeight(self, weight, azim)


    def setPolarWeight(self, weight, azim, polar):
        """

        setPolarWeight(FP_PRECISION weight, int azim, int polar)  

        Sets the polar weight for the given indexes.  

        Parameters
        ----------
        * weight :  
            the weight of the polar angle  
        * azim :  
            the azimuthal index corresponding to the angle  
        * azim :  
            the polar index corresponding to the angle  

        """
        return _openmoc.Quadrature_setPolarWeight(self, weight, azim, polar)


    def initialize(self):
        """

        initialize()  

        Initialize the polar quadrature azimuthal angles.  

        The parent class routine simply checks that number of polar and azimuthal angles have been
        set by the user and generates the azimuthal angles if not already generated.  

        """
        return _openmoc.Quadrature_initialize(self)


    def precomputeWeights(self, solve_3D):
        """

        precomputeWeights(bool solve_3D)  

        This private routine computes the product of the sine thetas and weights for each angle in
        the polar quadrature.  

        Note that this routine must be called after populating the sine thetas and weights arrays.  

        """
        return _openmoc.Quadrature_precomputeWeights(self, solve_3D)


    def toString(self):
        """

        toString() -> std::string  

        Converts this Quadrature to a character array of its attributes.  

        The character array includes the number of polar angles, the the values of the sine and
        weight of each polar angle, and the product of the sine and weight of each polar angle.  

        Returns
        -------
        a character array of the Quadrature's attributes  

        """
        return _openmoc.Quadrature_toString(self)

Quadrature_swigregister = _openmoc.Quadrature_swigregister
Quadrature_swigregister(Quadrature)

class TYPolarQuad(Quadrature):
    """


    Tabuchi-Yamamoto's polar quadrature.  

    C++ includes: src/Quadrature.h

    """
    __swig_setmethods__ = {}
    for _s in [Quadrature]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TYPolarQuad, name, value)
    __swig_getmethods__ = {}
    for _s in [Quadrature]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TYPolarQuad, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        TYPolarQuad()  

        Dummy constructor calls the parent constructor.  

        """
        this = _openmoc.new_TYPolarQuad()
        try:
            self.this.append(this)
        except:
            self.this = this

    def setNumPolarAngles(self, num_polar):
        """

        setNumPolarAngles(const int num_polar)  

        Set the number of polar angles to initialize.  

        Parameters
        ----------
        * num_polar :  
            the number of polar angles (maximum 6)  

        """
        return _openmoc.TYPolarQuad_setNumPolarAngles(self, num_polar)


    def initialize(self):
        """

        initialize()  

        Routine to initialize the polar quadrature.  

        This routine uses the tabulated values for the Tabuchi-Yamamoto polar angle quadrature,
        including the sine thetas and weights.  

        """
        return _openmoc.TYPolarQuad_initialize(self)


    def precomputeWeights(self, solve_3D):
        """

        precomputeWeights(bool solve_3D)  

        Calculates total weights for every azimuthal/polar combination based on the TY quadrature.  

        Parameters
        ----------
        * solve_3D :  
            Boolean indicating whether this is a 3D quadrature  

        """
        return _openmoc.TYPolarQuad_precomputeWeights(self, solve_3D)

    __swig_destroy__ = _openmoc.delete_TYPolarQuad
    __del__ = lambda self: None
TYPolarQuad_swigregister = _openmoc.TYPolarQuad_swigregister
TYPolarQuad_swigregister(TYPolarQuad)

class LeonardPolarQuad(Quadrature):
    """


    Leonard's polar quadrature.  

    C++ includes: src/Quadrature.h

    """
    __swig_setmethods__ = {}
    for _s in [Quadrature]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LeonardPolarQuad, name, value)
    __swig_getmethods__ = {}
    for _s in [Quadrature]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LeonardPolarQuad, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        LeonardPolarQuad()  

        Dummy constructor calls the parent constructor.  

        """
        this = _openmoc.new_LeonardPolarQuad()
        try:
            self.this.append(this)
        except:
            self.this = this

    def setNumPolarAngles(self, num_polar):
        """

        setNumPolarAngles(const int num_polar)  

        Set the number of polar angles to initialize.  

        Parameters
        ----------
        * num_polar :  
            the number of polar angles (4 or 6)  

        """
        return _openmoc.LeonardPolarQuad_setNumPolarAngles(self, num_polar)


    def initialize(self):
        """

        initialize()  

        Routine to initialize the polar quadrature.  

        This routine uses the tabulated values for the Leonard polar angle quadrature, including
        the sine thetas and weights.  

        """
        return _openmoc.LeonardPolarQuad_initialize(self)


    def precomputeWeights(self, solve_3D):
        """

        precomputeWeights(bool solve_3D)  

        Calculates total weights for every azimuthal/polar combination based on the Leonard polar
        quadrature.  

        Parameters
        ----------
        * solve_3D :  
            Boolean indicating whether this is a 3D quadrature  

        """
        return _openmoc.LeonardPolarQuad_precomputeWeights(self, solve_3D)

    __swig_destroy__ = _openmoc.delete_LeonardPolarQuad
    __del__ = lambda self: None
LeonardPolarQuad_swigregister = _openmoc.LeonardPolarQuad_swigregister
LeonardPolarQuad_swigregister(LeonardPolarQuad)

class GLPolarQuad(Quadrature):
    """


    Gauss-Legendre's polar quadrature.  

    C++ includes: src/Quadrature.h

    """
    __swig_setmethods__ = {}
    for _s in [Quadrature]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GLPolarQuad, name, value)
    __swig_getmethods__ = {}
    for _s in [Quadrature]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GLPolarQuad, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        GLPolarQuad()  

        Dummy constructor calls the parent constructor.  

        """
        this = _openmoc.new_GLPolarQuad()
        try:
            self.this.append(this)
        except:
            self.this = this

    def setNumPolarAngles(self, num_polar):
        """

        setNumPolarAngles(const int num_polar)  

        Set the number of polar angles to initialize.  

        Parameters
        ----------
        * num_polar :  
            the number of polar angles (maximum 12)  

        """
        return _openmoc.GLPolarQuad_setNumPolarAngles(self, num_polar)


    def initialize(self):
        """

        initialize()  

        Routine to initialize the polar quadrature.  

        This routine uses the tabulated values for the Gauss-Legendre polar angle quadrature,
        including the sine thetas and weights.  

        """
        return _openmoc.GLPolarQuad_initialize(self)


    def precomputeWeights(self, solve_3D):
        """

        precomputeWeights(bool solve_3D)  

        Calculates total weights for every azimuthal/polar combination based on the Gauss-Legendre
        polar quadrature.  

        Parameters
        ----------
        * solve_3D :  
            Boolean indicating whether this is a 3D quadrature  

        """
        return _openmoc.GLPolarQuad_precomputeWeights(self, solve_3D)


    def legendrePolynomial(self, n, x):
        return _openmoc.GLPolarQuad_legendrePolynomial(self, n, x)

    def logDerivLegendre(self, n, x):
        return _openmoc.GLPolarQuad_logDerivLegendre(self, n, x)

    def secondLogDerivLegendre(self, n, x):
        return _openmoc.GLPolarQuad_secondLogDerivLegendre(self, n, x)

    def getLegendreRoots(self, n):
        return _openmoc.GLPolarQuad_getLegendreRoots(self, n)

    def getGLWeights(self, roots, n):
        return _openmoc.GLPolarQuad_getGLWeights(self, roots, n)
    __swig_destroy__ = _openmoc.delete_GLPolarQuad
    __del__ = lambda self: None
GLPolarQuad_swigregister = _openmoc.GLPolarQuad_swigregister
GLPolarQuad_swigregister(GLPolarQuad)

class EqualWeightPolarQuad(Quadrature):
    """


    Equal weight polar quadrature.  

    C++ includes: src/Quadrature.h

    """
    __swig_setmethods__ = {}
    for _s in [Quadrature]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EqualWeightPolarQuad, name, value)
    __swig_getmethods__ = {}
    for _s in [Quadrature]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EqualWeightPolarQuad, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        EqualWeightPolarQuad()  

        Dummy constructor calls the parent constructor.  

        """
        this = _openmoc.new_EqualWeightPolarQuad()
        try:
            self.this.append(this)
        except:
            self.this = this

    def setNumPolarAngles(self, num_polar):
        """

        setNumPolarAngles(const int num_polar)  

        Set the number of polar angles to initialize.  

        Parameters
        ----------
        * num_polar :  
            the number of polar angles  

        """
        return _openmoc.EqualWeightPolarQuad_setNumPolarAngles(self, num_polar)


    def initialize(self):
        """

        initialize()  

        Routine to initialize the polar quadrature.  

        This routine generates the sine thetas and weights.  

        """
        return _openmoc.EqualWeightPolarQuad_initialize(self)


    def precomputeWeights(self, solve_3D):
        """

        precomputeWeights(bool solve_3D)  

        Calculates total weights for every azimuthal/polar combination based on the equal weight
        polar quadrature.  

        Parameters
        ----------
        * solve_3D :  
            Boolean indicating whether this is a 3D quadrature  

        """
        return _openmoc.EqualWeightPolarQuad_precomputeWeights(self, solve_3D)

    __swig_destroy__ = _openmoc.delete_EqualWeightPolarQuad
    __del__ = lambda self: None
EqualWeightPolarQuad_swigregister = _openmoc.EqualWeightPolarQuad_swigregister
EqualWeightPolarQuad_swigregister(EqualWeightPolarQuad)

class EqualAnglePolarQuad(Quadrature):
    """


    Equal angle polar quadrature.  

    C++ includes: src/Quadrature.h

    """
    __swig_setmethods__ = {}
    for _s in [Quadrature]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EqualAnglePolarQuad, name, value)
    __swig_getmethods__ = {}
    for _s in [Quadrature]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EqualAnglePolarQuad, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        EqualAnglePolarQuad()  

        Dummy constructor calls the parent constructor.  

        """
        this = _openmoc.new_EqualAnglePolarQuad()
        try:
            self.this.append(this)
        except:
            self.this = this

    def setNumPolarAngles(self, num_polar):
        """

        setNumPolarAngles(const int num_polar)  

        Set the number of polar angles to initialize.  

        Parameters
        ----------
        * num_polar :  
            the number of polar angles  

        """
        return _openmoc.EqualAnglePolarQuad_setNumPolarAngles(self, num_polar)


    def initialize(self):
        """

        initialize()  

        Routine to initialize the polar quadrature.  

        This routine generates the sine thetas and weights.  

        """
        return _openmoc.EqualAnglePolarQuad_initialize(self)


    def precomputeWeights(self, solve_3D):
        """

        precomputeWeights(bool solve_3D)  

        Calculates total weights for every azimuthal/polar combination based on the equal angle
        polar quadrature.  

        Parameters
        ----------
        * solve_3D :  
            Boolean indicating whether this is a 3D quadrature  

        """
        return _openmoc.EqualAnglePolarQuad_precomputeWeights(self, solve_3D)

    __swig_destroy__ = _openmoc.delete_EqualAnglePolarQuad
    __del__ = lambda self: None
EqualAnglePolarQuad_swigregister = _openmoc.EqualAnglePolarQuad_swigregister
EqualAnglePolarQuad_swigregister(EqualAnglePolarQuad)


_openmoc.FORWARD_swigconstant(_openmoc)
FORWARD = _openmoc.FORWARD

_openmoc.ADJOINT_swigconstant(_openmoc)
ADJOINT = _openmoc.ADJOINT

_openmoc.SCALAR_FLUX_swigconstant(_openmoc)
SCALAR_FLUX = _openmoc.SCALAR_FLUX

_openmoc.FISSION_SOURCE_swigconstant(_openmoc)
FISSION_SOURCE = _openmoc.FISSION_SOURCE

_openmoc.TOTAL_SOURCE_swigconstant(_openmoc)
TOTAL_SOURCE = _openmoc.TOTAL_SOURCE
class Solver(_object):
    """


    This is an abstract base class which different Solver subclasses implement for different
    architectures or source iteration algorithms.  

    C++ includes: src/Solver.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Solver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Solver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmoc.delete_Solver
    __del__ = lambda self: None

    def setGeometry(self, geometry):
        """

        setGeometry(Geometry *geometry)  

        Sets the Geometry for the Solver.  

        This is a private setter method for the Solver and is not intended to be called by the
        user.  

        Parameters
        ----------
        * geometry :  
            a pointer to a Geometry object  

        """
        return _openmoc.Solver_setGeometry(self, geometry)


    def getGeometry(self):
        """

        getGeometry() -> Geometry *  

        Returns a pointer to the Geometry.  

        Returns
        -------
        a pointer to the Geometry  

        """
        return _openmoc.Solver_getGeometry(self)


    def getTrackGenerator(self):
        """

        getTrackGenerator() -> TrackGenerator *  

        Returns a pointer to the TrackGenerator.  

        Returns
        -------
        a pointer to the TrackGenerator  

        """
        return _openmoc.Solver_getTrackGenerator(self)


    def getFSRVolume(self, fsr_id):
        """

        getFSRVolume(int fsr_id) -> FP_PRECISION  

        Returns the calculated volume for a flat source region.  

        Parameters
        ----------
        * fsr_id :  
            the flat source region ID of interest  

        Returns
        -------
        the flat source region volume  

        """
        return _openmoc.Solver_getFSRVolume(self, fsr_id)


    def getNumPolarAngles(self):
        """

        getNumPolarAngles() -> int  

        Returns the number of angles used for the polar quadrature.  

        Returns
        -------
        the number of polar angles  

        """
        return _openmoc.Solver_getNumPolarAngles(self)


    def getNumIterations(self):
        """

        getNumIterations() -> int  

        Returns the number of source iterations to converge the source.  

        Returns
        -------
        the number of iterations  

        """
        return _openmoc.Solver_getNumIterations(self)


    def getTotalTime(self):
        """

        getTotalTime() -> double  

        Returns the total time to converge the source (seconds).  

        Returns
        -------
        the time to converge the source (seconds)  

        """
        return _openmoc.Solver_getTotalTime(self)


    def getKeff(self):
        """

        getKeff() -> FP_PRECISION  

        Returns the converged eigenvalue $ k_{eff} $.  

        Returns
        -------
        the converged eigenvalue $ k_{eff} $  

        """
        return _openmoc.Solver_getKeff(self)


    def getConvergenceThreshold(self):
        """

        getConvergenceThreshold() -> FP_PRECISION  

        Returns the threshold for source/flux convergence.  

        Returns
        -------
        the threshold for source/flux convergence  

        """
        return _openmoc.Solver_getConvergenceThreshold(self)


    def getMaxOpticalLength(self):
        """

        getMaxOpticalLength() -> FP_PRECISION  

        Get the maximum allowable optical length for a track segment.  

        Returns
        -------
        The max optical length  

        """
        return _openmoc.Solver_getMaxOpticalLength(self)


    def isUsingDoublePrecision(self):
        """

        isUsingDoublePrecision() -> bool  

        Returns whether the solver is using double floating point precision.  

        Returns
        -------
        true if using double precision float point arithmetic  

        """
        return _openmoc.Solver_isUsingDoublePrecision(self)


    def isUsingExponentialInterpolation(self):
        """

        isUsingExponentialInterpolation() -> bool  

        Returns whether the Solver uses linear interpolation to compute exponentials.  

        Returns
        -------
        true if using linear interpolation to compute exponentials  

        """
        return _openmoc.Solver_isUsingExponentialInterpolation(self)


    def getFSRSource(self, fsr_id, group):
        """

        getFSRSource(int fsr_id, int group) -> FP_PRECISION  

        Returns the source for some energy group for a flat source region.  

        This is a helper routine used by the openmoc.process module.  

        Parameters
        ----------
        * fsr_id :  
            the ID for the FSR of interest  
        * group :  
            the energy group of interest  

        Returns
        -------
        the flat source region source  

        """
        return _openmoc.Solver_getFSRSource(self, fsr_id, group)


    def getFlux(self, fsr_id, group):
        """

        getFlux(int fsr_id, int group) -> FP_PRECISION  

        Returns the scalar flux for some FSR and energy group.  

        Parameters
        ----------
        * fsr_id :  
            the ID for the FSR of interest  
        * group :  
            the energy group of interest  

        Returns
        -------
        the FSR scalar flux  

        """
        return _openmoc.Solver_getFlux(self, fsr_id, group)


    def getFluxes(self, out_fluxes):
        """

        getFluxes(FP_PRECISION *out_fluxes, int num_fluxes)=0  

        """
        return _openmoc.Solver_getFluxes(self, out_fluxes)


    def getBoundaryFlux(self, track_id, fwd):
        return _openmoc.Solver_getBoundaryFlux(self, track_id, fwd)

    def setTrackGenerator(self, track_generator):
        """

        setTrackGenerator(TrackGenerator *track_generator)  

        Sets the Solver's TrackGenerator with characteristic Tracks.  

        The TrackGenerator must already have generated Tracks and have used ray tracing to
        segmentize them across the Geometry. This should be initated in Python prior to assigning
        the TrackGenerator to the Solver:  


        Parameters
        ----------
        * track_generator :  
            a pointer to a TrackGenerator object  

        """
        val = _openmoc.Solver_setTrackGenerator(self, track_generator)

          # SWIG 3
        if 'track_generator' in locals():
          track_generator = locals()['track_generator']
        elif 'args' in locals() and 'track_generator' in locals()['args']:
          track_generator = locals()['args']['track_generator']
        elif 'kwargs' in locals() and 'track_generator' in locals()['kwargs']:
          track_generator = locals()['kwargs']['track_generator']

        # SWIG 2
        else:
          track_generator = locals()['args'][0]

        track_generator.thisown = False


        return val


    def setConvergenceThreshold(self, threshold):
        """

        setConvergenceThreshold(FP_PRECISION threshold)  

        Sets the threshold for source/flux convergence.  

        The default threshold for convergence is 1E-5.  

        Parameters
        ----------
        * source_thresh :  
            the threshold for source/flux convergence  

        """
        return _openmoc.Solver_setConvergenceThreshold(self, threshold)


    def setFluxes(self, in_fluxes):
        """

        setFluxes(FP_PRECISION *in_fluxes, int num_fluxes)=0  

        """
        return _openmoc.Solver_setFluxes(self, in_fluxes)


    def setFixedSourceByFSR(self, fsr_id, group, source):
        """

        setFixedSourceByFSR(int fsr_id, int group, FP_PRECISION source)  

        Assign a fixed source for a flat source region and energy group.  

        Parameters
        ----------
        * fsr_id :  
            the flat source region ID  
        * group :  
            the energy group  
        * source :  
            the volume-averaged source in this group  

        """
        return _openmoc.Solver_setFixedSourceByFSR(self, fsr_id, group, source)


    def setFixedSourceByCell(self, cell, group, source):
        """

        setFixedSourceByCell(Cell *cell, int group, FP_PRECISION source)  

        Assign a fixed source for a Cell and energy group.  

        Parameters
        ----------
        * cell :  
            the Cell of interest  
        * group :  
            the energy group  
        * source :  
            the volume-averaged source in this group  

        """
        return _openmoc.Solver_setFixedSourceByCell(self, cell, group, source)


    def setFixedSourceByMaterial(self, material, group, source):
        """

        setFixedSourceByMaterial(Material *material, int group, FP_PRECISION source)  

        Assign a fixed source for a Material and energy group.  

        Parameters
        ----------
        * material :  
            the Material of interest  
        * group :  
            the energy group  
        * source :  
            the volume-averaged source in this group  

        """
        return _openmoc.Solver_setFixedSourceByMaterial(self, material, group, source)


    def setMaxOpticalLength(self, max_optical_length):
        """

        setMaxOpticalLength(FP_PRECISION max_optical_length)  

        Set the maximum allowable optical length for a track segment.  

        Parameters
        ----------
        * max_optical_length :  
            The max optical length  

        """
        return _openmoc.Solver_setMaxOpticalLength(self, max_optical_length)


    def setExpPrecision(self, precision):
        """

        setExpPrecision(FP_PRECISION precision)  

        Set the precision, or maximum allowable approximation error, of the the exponential
        interpolation table.  

        By default, the precision is 1E-5 based on the analysis in Yamamoto's 2003 paper.  

        Parameters
        ----------
        * precision :  
            the precision of the exponential interpolation table,  

        """
        return _openmoc.Solver_setExpPrecision(self, precision)


    def useExponentialInterpolation(self):
        """

        useExponentialInterpolation()  

        Informs the Solver to use linear interpolation to compute the exponential in the transport
        equation.  

        """
        return _openmoc.Solver_useExponentialInterpolation(self)


    def useExponentialIntrinsic(self):
        """

        useExponentialIntrinsic()  

        Informs the Solver to use the exponential intrinsic exp(...) function to compute the
        exponential in the transport equation.  

        """
        return _openmoc.Solver_useExponentialIntrinsic(self)


    def initializeExpEvaluator(self):
        """

        initializeExpEvaluator()  

        Initializes new ExpEvaluator object to compute exponentials.  

        """
        return _openmoc.Solver_initializeExpEvaluator(self)


    def initializeMaterials(self, mode=FORWARD):
        """

        initializeMaterials(solverMode mode=FORWARD)  

        Initializes the Material fission matrices.  

        In an adjoint calculation, this routine will transpose the scattering and fission matrices
        in each material.  

        Parameters
        ----------
        * mode :  
            the solution type (FORWARD or ADJOINT)  

        """
        return _openmoc.Solver_initializeMaterials(self, mode)


    def initializeFSRs(self):
        """

        initializeFSRs()  

        Initializes the FSR volumes and Materials array.  

        This method assigns each FSR a unique, monotonically increasing ID, sets the Material for
        each FSR, and assigns a volume based on the cumulative length of all of the segments
        inside the FSR.  

        """
        return _openmoc.Solver_initializeFSRs(self)


    def countFissionableFSRs(self):
        """

        countFissionableFSRs()  

        Counts the number of fissionable flat source regions.  

        This routine is used by the Solver::computeEigenvalue(...) routine which uses the number
        of fissionable FSRs to normalize the residual on the fission source distribution.  

        """
        return _openmoc.Solver_countFissionableFSRs(self)


    def initializeFixedSources(self):
        """

        initializeFixedSources()  

        Assigns fixed sources assigned by Cell, Material to FSRs.  

        Fixed sources assigned by Material  

        """
        return _openmoc.Solver_initializeFixedSources(self)


    def initializeCmfd(self):
        """

        initializeCmfd()  

        Initializes a Cmfd object for acceleratiion prior to source iteration.  

        Instantiates a dummy Cmfd object if one was not assigned to the Solver by the user and
        initializes FSRs, materials, fluxes and the Mesh object. This method is for internal use
        only and should not be called directly by the user.  

        """
        return _openmoc.Solver_initializeCmfd(self)


    def resetMaterials(self, mode=FORWARD):
        """

        resetMaterials(solverMode mode=FORWARD)  

        Returns the Material data to its original state.  

        In an adjoint calculation, the scattering and fission matrices in each material are
        transposed during initialization. This routine returns both matrices to their original
        (FORWARD) state at the end of a calculation.  

        Parameters
        ----------
        * mode :  
            the solution type (FORWARD or ADJOINT)  

        """
        return _openmoc.Solver_resetMaterials(self, mode)


    def fissionTransportSweep(self):
        """

        fissionTransportSweep()  

        This method performs one transport sweep using the fission source.  

        This is a helper routine used for Krylov subspace methods.  

        """
        return _openmoc.Solver_fissionTransportSweep(self)


    def scatterTransportSweep(self):
        """

        scatterTransportSweep()  

        This method performs one transport sweep using the scatter source.  

        This is a helper routine used for Krylov subspace methods.  

        """
        return _openmoc.Solver_scatterTransportSweep(self)


    def initializeFluxArrays(self):
        """

        initializeFluxArrays()=0  

        Initializes Track boundary angular and FSR scalar flux arrays.  

        """
        return _openmoc.Solver_initializeFluxArrays(self)


    def initializeSourceArrays(self):
        """

        initializeSourceArrays()=0  

        Allocates memory for FSR source arrays.  

        """
        return _openmoc.Solver_initializeSourceArrays(self)


    def zeroTrackFluxes(self):
        """

        zeroTrackFluxes()=0  

        Zero each Track's boundary fluxes for each energy group and polar angle in the "forward"
        and "reverse" directions.  

        """
        return _openmoc.Solver_zeroTrackFluxes(self)


    def flattenFSRFluxes(self, value):
        """

        flattenFSRFluxes(FP_PRECISION value)=0  

        Set the scalar flux for each FSR and energy group to some value.  

        Parameters
        ----------
        * value :  
            the value to assign to each FSR scalar flux  

        """
        return _openmoc.Solver_flattenFSRFluxes(self, value)


    def storeFSRFluxes(self):
        """

        storeFSRFluxes()=0  

        Stores the current scalar fluxes in the old scalar flux array.  

        """
        return _openmoc.Solver_storeFSRFluxes(self)


    def normalizeFluxes(self):
        """

        normalizeFluxes()=0  

        Normalizes all FSR scalar fluxes and Track boundary angular fluxes to the total fission
        source (times $ \nu $).  

        """
        return _openmoc.Solver_normalizeFluxes(self)


    def computeFSRSources(self):
        """

        computeFSRSources()=0  

        Computes the total source (fission, scattering, fixed) for each FSR and energy group.  

        """
        return _openmoc.Solver_computeFSRSources(self)


    def computeFSRFissionSources(self):
        """

        computeFSRFissionSources()=0  

        Computes the total fission source for each FSR and energy group.  

        """
        return _openmoc.Solver_computeFSRFissionSources(self)


    def computeFSRScatterSources(self):
        """

        computeFSRScatterSources()=0  

        Computes the total scattering source for each FSR and energy group.  

        """
        return _openmoc.Solver_computeFSRScatterSources(self)


    def computeResidual(self, res_type):
        """

        computeResidual(residualType res_type)=0 -> double  

        Computes the residual between successive flux/source iterations.  

        Parameters
        ----------
        * res_type :  
            the residual type (SCALAR_FLUX, FISSION_SOURCE, TOTAL_SOURCE)  

        Returns
        -------
        the total residual summed over FSRs and energy groups  

        """
        return _openmoc.Solver_computeResidual(self, res_type)


    def computeKeff(self):
        """

        computeKeff()=0  

        Compute $ k_{eff} $ from successive fission sources.  

        """
        return _openmoc.Solver_computeKeff(self)


    def addSourceToScalarFlux(self):
        """

        addSourceToScalarFlux()=0  

        Add the source term contribution in the transport equation to the FSR scalar flux.  

        """
        return _openmoc.Solver_addSourceToScalarFlux(self)


    def transportSweep(self):
        """

        transportSweep()=0  

        This method performs one transport swep.  

        """
        return _openmoc.Solver_transportSweep(self)


    def computeFlux(self, max_iters=1000, mode=FORWARD, only_fixed_source=True):
        """

        computeFlux(int max_iters=1000, solverMode mode=FORWARD, bool only_fixed_source=true)  

        Computes the scalar flux distribution by performing a series of transport sweeps.  

        This is the main method exposed to the user through the Python interface to compute the
        scalar flux distribution, e.g., for a fixed source calculation. This routine makes an
        initial guess for scalar and boundary fluxes and performs transport sweep until
        convergence.  

        By default, this method will perform a maximum of 1000 transport sweeps with a 1E-5
        threshold on the average FSR scalar flux. These values may be freely modified by the user
        at runtime.  

        The only_fixed_source runtime parameter may be used to control the type of source
        distribution used in the calculation. By default, this paramter is true and only the fixed
        sources specified by the user will be considered. Alternatively, when the parameter is
        false, the source will be computed as the scattering and fission sources resulting from a
        previously computed flux distribution (e.g., an eigenvalue calculation) in addition to any
        user-defined fixed sources.  

        This method may be called by the user to compute the scalar flux for a fixed source
        distribution from Python as follows:  



                 Alternatively, as described above, this method may be called by
                 the user in Python to compute the flux from a superposition of
                 fixed and / or eigenvalue sources as follows:  


        Parameters
        ----------
        * max_iters :  
            the maximum number of source iterations to allow  
        * mode :  
            the solution type (FORWARD or ADJOINT)  
        * only_fixed_source :  
            use only fixed sources (true by default)  

        """
        return _openmoc.Solver_computeFlux(self, max_iters, mode, only_fixed_source)


    def computeSource(self, max_iters=1000, mode=FORWARD, k_eff=1.0, res_type=TOTAL_SOURCE):
        """

        computeSource(int max_iters=1000, solverMode mode=FORWARD, double k_eff=1.0, residualType
            res_type=TOTAL_SOURCE)  

        Computes the total source distribution by performing a series of transport sweep and
        source updates.  

        This is the main method exposed to the user through the Python interface to compute the
        source distribution, e.g., for a fixed and/or external source calculation. This routine
        makes an initial guess for the scalar and boundary fluxes and performs transport sweeps
        and source updates until convergence.  

        By default, this method will perform a maximum of 1000 transport sweeps with a 1E-5
        threshold on the integrated FSR total source. These values may be freely modified by the
        user at runtime.  

        The k_eff parameter may be used for fixed source calculations with fissionable material
        (e.g., start-up in a reactor from a fixed external source). In this case, the user must
        "guess" the critical eigenvalue to be be used to scale the fission source.  

        The res_type parameter may be used to control the convergence criterion - SCALAR_FLUX,
        TOTAL_SOURCE (default) and FISSION_SOURCE are all supported options in OpenMOC at this
        time.  

        This method may be called by the user from Python as follows:  


        Parameters
        ----------
        * max_iters :  
            the maximum number of source iterations to allow  
        * mode :  
            the solution type (FORWARD or ADJOINT)  
        * k_eff :  
            the sub/super-critical eigenvalue (default 1.0)  
        * res_type :  
            the type of residual used for the convergence criterion  

        """
        return _openmoc.Solver_computeSource(self, max_iters, mode, k_eff, res_type)


    def computeEigenvalue(self, max_iters=1000, mode=FORWARD, res_type=FISSION_SOURCE):
        """

        computeEigenvalue(int max_iters=1000, solverMode mode=FORWARD, residualType
            res_type=FISSION_SOURCE)  

        Computes keff by performing a series of transport sweep and source updates.  

        This is the main method exposed to the user through the Python interface to perform an
        eigenvalue calculation. The method makes an initial guess for the scalar and boundary
        fluxes and performs transport sweeps and source updates until convergence.  

        By default, this method will perform a maximum of 1000 transport sweeps with a 1E-5
        threshold on the integrated FSR fission source. These values may be freely modified by the
        user at runtime.  

        The res_type parameter may be used to control the convergence criterion - SCALAR_FLUX,
        TOTAL_SOURCE and FISSION_SOURCE (default) are all supported options in OpenMOC at this
        time.  


        Parameters
        ----------
        * max_iters :  
            the maximum number of source iterations to allow  
        * mode :  
            the solution type (FORWARD or ADJOINT)  
        * res_type :  
            the type of residual used for the convergence criterion  

        """
        return _openmoc.Solver_computeEigenvalue(self, max_iters, mode, res_type)


    def computeFSRFissionRates(self, fission_rates):
        """

        computeFSRFissionRates(double *fission_rates, int num_FSRs)=0  

        Computes the volume-weighted, energy integrated fission rate in each FSR and stores them
        in an array indexed by FSR ID.  

        This is a helper method for SWIG to allow users to retrieve FSR fission rates as a NumPy
        array. An example of how this method can be called from Python is as follows:  


        Parameters
        ----------
        * fission_rates :  
            an array to store the fission rates (implicitly passed in as a NumPy array from
            Python)  
        * num_FSRs :  
            the number of FSRs passed in from Python  

        """
        return _openmoc.Solver_computeFSRFissionRates(self, fission_rates)


    def printTimerReport(self):
        """

        printTimerReport()  

        Prints a report of the timing statistics to the console.  

        """
        return _openmoc.Solver_printTimerReport(self)

Solver_swigregister = _openmoc.Solver_swigregister
Solver_swigregister(Solver)

class CPUSolver(Solver):
    """


    This a subclass of the Solver class for multi-core CPUs using OpenMP multi-threading.  

    C++ includes: src/CPUSolver.h

    """
    __swig_setmethods__ = {}
    for _s in [Solver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPUSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Solver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPUSolver, name)
    __repr__ = _swig_repr

    def __init__(self, track_generator=None):
        """

        CPUSolver(TrackGenerator *track_generator=NULL)  

        Constructor initializes array pointers for Tracks and Materials.  

        The constructor retrieves the number of energy groups and FSRs and azimuthal angles from
        the Geometry and TrackGenerator if passed in as parameters by the user. The constructor
        initalizes the number of OpenMP threads to a default of 1.  

        Parameters
        ----------
        * track_generator :  
            an optional pointer to the TrackGenerator  

        """
        this = _openmoc.new_CPUSolver(track_generator)
        try:
            self.this.append(this)
        except:
            self.this = this

          # SWIG 3
        if 'track_generator' in locals():
          track_generator = locals()['track_generator']
        elif 'args' in locals() and 'track_generator' in locals()['args']:
          track_generator = locals()['args']['track_generator']
        elif 'kwargs' in locals() and 'track_generator' in locals()['kwargs']:
          track_generator = locals()['kwargs']['track_generator']

        # SWIG 2
        else:
          track_generator = locals()['args'][0]

        # Only disown if user specified optional track_generator parameter
        if track_generator:
          track_generator.thisown = False




    def tallyScalarFlux(self, curr_segment, next_segment, azim_index, track_flux, fsr_flux, map_fsr_to_cells):
        """

        tallyScalarFlux(dev_segment *curr_segment, int azim_index, int energy_group, dev_material
            *materials, FP_PRECISION *track_flux, FP_PRECISION *reduced_sources, FP_PRECISION
            *scalar_flux) -> __device__ void  

        Computes the contribution to the FSR scalar flux from a Track segment in a single energy
        group.  

        This method integrates the angular flux for a Track segment across energy groups and polar
        angles, and tallies it into the FSR scalar flux, and updates the Track's angular flux.  

        Parameters
        ----------
        * curr_segment :  
            a pointer to the Track segment of interest  
        * azim_index :  
            a pointer to the azimuthal angle index for this segment  
        * energy_group :  
            the energy group of interest  
        * materials :  
            the array of dev_material pointers  
        * track_flux :  
            a pointer to the Track's angular flux  
        * reduced_sources :  
            the array of FSR sources / total xs  
        * scalar_flux :  
            the array of FSR scalar fluxes  

        """
        return _openmoc.CPUSolver_tallyScalarFlux(self, curr_segment, next_segment, azim_index, track_flux, fsr_flux, map_fsr_to_cells)


    def tallyCurrent(self, curr_segment, azim_index, track_flux, fwd):
        return _openmoc.CPUSolver_tallyCurrent(self, curr_segment, azim_index, track_flux, fwd)

    def transferBoundaryFlux(self, track_id, azim_index, direction, track_flux):
        """

        transferBoundaryFlux(dev_track *curr_track, int azim_index, FP_PRECISION *track_flux,
            FP_PRECISION *boundary_flux, int energy_angle_index, bool direction) -> __device__
            void  

        Updates the boundary flux for a Track given boundary conditions.  

        For reflective and periodic boundary conditions, the outgoing boundary flux for the Track
        is given to the corresponding reflecting or periodic Track. For vacuum boundary
        conditions, the outgoing flux is tallied as leakage. Note: Only one energy group is
        transferred by this routine.  

        Parameters
        ----------
        * curr_track :  
            a pointer to the Track of interest  
        * azim_index :  
            a pointer to the azimuthal angle index for this segment  
        * track_flux :  
            an array of the outgoing Track flux  
        * boundary_flux :  
            an array of all angular fluxes  
        * weights :  
            an array of Quadrature weights  
        * energy_angle_index :  
            the energy group index  
        * direction :  
            the Track direction (forward - true, reverse - false)  

        """
        return _openmoc.CPUSolver_transferBoundaryFlux(self, track_id, azim_index, direction, track_flux)


    def getNumThreads(self):
        """

        getNumThreads() -> int  

        Returns the number of shared memory OpenMP threads in use.  

        Returns
        -------
        the number of threads  

        """
        return _openmoc.CPUSolver_getNumThreads(self)


    def getFluxes(self, out_fluxes):
        """

        getFluxes(FP_PRECISION *out_fluxes, int num_fluxes)  

        Fills an array with the scalar fluxes.  

        This class method is a helper routine called by the OpenMOC Python "openmoc.krylov"
        module for Krylov subspace methods. Although this method appears to require two arguments,
        in reality it only requires one due to SWIG and would be called from within Python as
        follows:  


        Parameters
        ----------
        * fluxes :  
            an array of FSR scalar fluxes in each energy group  
        * num_fluxes :  
            the total number of FSR flux values  

        """
        return _openmoc.CPUSolver_getFluxes(self, out_fluxes)


    def setNumThreads(self, num_threads):
        """

        setNumThreads(int num_threads)  

        Sets the number of shared memory OpenMP threads to use (>0).  

        Parameters
        ----------
        * num_threads :  
            the number of threads  

        """
        return _openmoc.CPUSolver_setNumThreads(self, num_threads)


    def setFluxes(self, in_fluxes):
        """

        setFluxes(FP_PRECISION *in_fluxes, int num_fluxes)  

        Set the flux array for use in transport sweep source calculations.  This is a helper
        method for the checkpoint restart capabilities, as well as the IRAMSolver in the
        openmoc.krylov submodule. This routine may be used as follows from within Python:  



                 NOTE: This routine stores a pointer to the fluxes for the Solver
                 to use during transport sweeps and other calculations. Hence, the
                 flux array pointer is shared between NumPy and the Solver.  

        Parameters
        ----------
        * in_fluxes :  
            an array with the fluxes to use  
        * num_fluxes :  
            the number of flux values (# groups x # FSRs)  

        """
        return _openmoc.CPUSolver_setFluxes(self, in_fluxes)


    def initializeFluxArrays(self):
        """

        initializeFluxArrays()  

        Allocates memory for Track boundary angular and FSR scalar fluxes.  

        Deletes memory for old flux arrays if they were allocated for a previous simulation.  

        """
        return _openmoc.CPUSolver_initializeFluxArrays(self)


    def initializeSourceArrays(self):
        """

        initializeSourceArrays()  

        Allocates memory for FSR source arrays.  

        Deletes memory for old source arrays if they were allocated for a previous simulation.  

        """
        return _openmoc.CPUSolver_initializeSourceArrays(self)


    def initializeFixedSources(self):
        """

        initializeFixedSources()  

        Populates array of fixed sources assigned by FSR.  

        """
        return _openmoc.CPUSolver_initializeFixedSources(self)


    def initializeFSRs(self):
        """

        initializeFSRs()  

        Initializes the FSR volumes and Materials array.  

        This method gets an array of OpenMP mutual exclusion locks for each FSR for use in the
        transport sweep algorithm.  

        """
        return _openmoc.CPUSolver_initializeFSRs(self)


    def zeroTrackFluxes(self):
        """

        zeroTrackFluxes()  

        Zero each Track's boundary fluxes for each energy group and polar angle in the "forward"
        and "reverse" directions.  

        """
        return _openmoc.CPUSolver_zeroTrackFluxes(self)


    def copyBoundaryFluxes(self):
        return _openmoc.CPUSolver_copyBoundaryFluxes(self)

    def flattenFSRFluxes(self, value):
        """

        flattenFSRFluxes(FP_PRECISION value)  

        Set the scalar flux for each FSR and energy group to some value.  

        Parameters
        ----------
        * value :  
            the value to assign to each FSR scalar flux  

        """
        return _openmoc.CPUSolver_flattenFSRFluxes(self, value)


    def storeFSRFluxes(self):
        """

        storeFSRFluxes()  

        Stores the FSR scalar fluxes in the old scalar flux array.  

        """
        return _openmoc.CPUSolver_storeFSRFluxes(self)


    def normalizeFluxes(self):
        """

        normalizeFluxes()  

        Normalizes all FSR scalar fluxes and Track boundary angular fluxes to the total fission
        source (times $ \nu $).  

        """
        return _openmoc.CPUSolver_normalizeFluxes(self)


    def computeFSRSources(self):
        """

        computeFSRSources()  

        Computes the total source (fission, scattering, fixed) in each FSR.  

        This method computes the total source in each FSR based on this iteration's current
        approximation to the scalar flux.  

        """
        return _openmoc.CPUSolver_computeFSRSources(self)


    def computeFSRFissionSources(self):
        """

        computeFSRFissionSources()  

        Computes the total fission source in each FSR.  

        This method is a helper routine for the openmoc.krylov submodule.  

        """
        return _openmoc.CPUSolver_computeFSRFissionSources(self)


    def computeFSRScatterSources(self):
        """

        computeFSRScatterSources()  

        Computes the total scattering source in each FSR.  

        This method is a helper routine for the openmoc.krylov submodule.  

        """
        return _openmoc.CPUSolver_computeFSRScatterSources(self)


    def transportSweep(self):
        """

        transportSweep()  

        This method performs one transport sweep of all azimuthal angles, Tracks, Track segments,
        polar angles and energy groups.  

        The method integrates the flux along each Track and updates the boundary fluxes for the
        corresponding output Track, while updating the scalar flux in each flat source region.  

        """
        return _openmoc.CPUSolver_transportSweep(self)


    def addSourceToScalarFlux(self):
        """

        addSourceToScalarFlux()  

        Add the source term contribution in the transport equation to the FSR scalar flux.  

        """
        return _openmoc.CPUSolver_addSourceToScalarFlux(self)


    def computeKeff(self):
        """

        computeKeff()  

        Compute $ k_{eff} $ from successive fission sources.  

        """
        return _openmoc.CPUSolver_computeKeff(self)


    def computeResidual(self, res_type):
        """

        computeResidual(residualType res_type) -> double  

        Computes the residual between source/flux iterations.  

        Parameters
        ----------
        * res_type :  
            the type of residuals to compute (SCALAR_FLUX, FISSION_SOURCE, TOTAL_SOURCE)  

        Returns
        -------
        the average residual in each FSR  

        """
        return _openmoc.CPUSolver_computeResidual(self, res_type)


    def computeFSRFissionRates(self, fission_rates):
        """

        computeFSRFissionRates(double *fission_rates, int num_FSRs)  

        Computes the volume-integrated, energy-integrated nu-fission rate in each FSR and stores
        them in an array indexed by FSR ID.  

        This is a helper method for SWIG to allow users to retrieve FSR nu-fission rates as a
        NumPy array. An example of how this method can be called from Python is as follows:  


        Parameters
        ----------
        * fission_rates :  
            an array to store the nu-fission rates (implicitly passed in as a NumPy array from
            Python)  
        * num_FSRs :  
            the number of FSRs passed in from Python  

        """
        return _openmoc.CPUSolver_computeFSRFissionRates(self, fission_rates)


    def initializePartialCurrentArrays(self):
        return _openmoc.CPUSolver_initializePartialCurrentArrays(self)

    def setNumSurfaces(self, number_surfaces):
        return _openmoc.CPUSolver_setNumSurfaces(self, number_surfaces)

    def setReferencePartialCurrents(self, cell_from, cell_to, group, p, ref_current):
        return _openmoc.CPUSolver_setReferencePartialCurrents(self, cell_from, cell_to, group, p, ref_current)

    def getReferencePartialCurrents(self, cell_from, cell_to, index):
        return _openmoc.CPUSolver_getReferencePartialCurrents(self, cell_from, cell_to, index)

    def getOngoingPartialCurrent(self, index, group, azim, p):
        return _openmoc.CPUSolver_getOngoingPartialCurrent(self, index, group, azim, p)

    def getAngularPartialCurrent(self, cell_from, cell_to, group, azim, p):
        return _openmoc.CPUSolver_getAngularPartialCurrent(self, cell_from, cell_to, group, azim, p)

    def resetOngoingPartialCurrentsArray(self):
        return _openmoc.CPUSolver_resetOngoingPartialCurrentsArray(self)
    __swig_destroy__ = _openmoc.delete_CPUSolver
    __del__ = lambda self: None
CPUSolver_swigregister = _openmoc.CPUSolver_swigregister
CPUSolver_swigregister(CPUSolver)


_openmoc.VACUUM_swigconstant(_openmoc)
VACUUM = _openmoc.VACUUM

_openmoc.REFLECTIVE_swigconstant(_openmoc)
REFLECTIVE = _openmoc.REFLECTIVE

_openmoc.PERIODIC_swigconstant(_openmoc)
PERIODIC = _openmoc.PERIODIC

_openmoc.BOUNDARY_NONE_swigconstant(_openmoc)
BOUNDARY_NONE = _openmoc.BOUNDARY_NONE

def surface_id():
    """

    surface_id() -> int  

    Returns an auto-generated unique surface ID.  

    This method is intended as a utility mehtod for user's writing OpenMOC input files. The
    method makes use of a static surface ID which is incremented each time the method is
    called to enable unique generation of monotonically increasing IDs. The method's first ID
    begins at 10000. Hence, user-defined surface IDs greater than or equal to 10000 are
    prohibited.  

    """
    return _openmoc.surface_id()

def reset_surface_id():
    """

    reset_surface_id()  

    Resets the auto-generated unique Surface ID counter to 10000.  

    """
    return _openmoc.reset_surface_id()

def maximize_surface_id(surface_id):
    """

    maximize_surface_id(int surface_id)  

    Maximize the auto-generated unique Surface ID counter.  

    This method updates the auto-generated unique Surface ID counter if the input parameter is
    greater than the present value. This is useful for the OpenMC compatibility module to
    ensure that the auto-generated Surface IDs do not collide with those created in OpenMC.  

    Parameters
    ----------
    * surface_id :  
        the id assigned to the auto-generated counter  

    """
    return _openmoc.maximize_surface_id(surface_id)

_openmoc.PLANE_swigconstant(_openmoc)
PLANE = _openmoc.PLANE

_openmoc.ZCYLINDER_swigconstant(_openmoc)
ZCYLINDER = _openmoc.ZCYLINDER

_openmoc.XPLANE_swigconstant(_openmoc)
XPLANE = _openmoc.XPLANE

_openmoc.YPLANE_swigconstant(_openmoc)
YPLANE = _openmoc.YPLANE

_openmoc.ZPLANE_swigconstant(_openmoc)
ZPLANE = _openmoc.ZPLANE

_openmoc.QUADRATIC_swigconstant(_openmoc)
QUADRATIC = _openmoc.QUADRATIC
class Surface(_object):
    """


    Represents a general Surface in 3D.  

    The Surface class and its subclasses are used to define the geometry for an OpenMOC
    simulation using a constructive solid geometry (CSG) formalism. Surfaces are used during
    ray tracing of charateristic tracks across the geometry.  

    C++ includes: src/Surface.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Surface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Surface, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmoc.delete_Surface
    __del__ = lambda self: None

    def getUid(self):
        """

        getUid() const  -> int  

        Return the Surface's unique ID.  

        Returns
        -------
        the Surface's unique ID  

        """
        return _openmoc.Surface_getUid(self)


    def getId(self):
        """

        getId() const  -> int  

        Return the Surface's user-defined ID.  

        Returns
        -------
        the Surface's user-defined ID  

        """
        return _openmoc.Surface_getId(self)


    def getName(self):
        """

        getName() const  -> char *  

        Return the user-defined name of the Surface.  

        Returns
        -------
        the Surface name  

        """
        return _openmoc.Surface_getName(self)


    def getSurfaceType(self):
        """

        getSurfaceType() -> surfaceType  

        Return the type of Surface (ie, XPLANE, ZCYLINDER, etc).  

        Returns
        -------
        the Surface type  

        """
        return _openmoc.Surface_getSurfaceType(self)


    def getBoundaryType(self):
        """

        getBoundaryType() -> boundaryType  

        Returns the type of boundary conditions for this Surface (REFLECTIVE, VACUUM or
        BOUNDARY_NONE)  

        Returns
        -------
        the type of boundary condition type for this Surface  

        """
        return _openmoc.Surface_getBoundaryType(self)


    def getMinX(self, halfspace):
        """

        getMinX(int halfspace)=0 -> double  

        Returns the minimum x value for one of this Surface's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the minimum x value  

        """
        return _openmoc.Surface_getMinX(self, halfspace)


    def getMaxX(self, halfspace):
        """

        getMaxX(int halfspace)=0 -> double  

        Returns the maximum x value for one of this Surface's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the maximum x value  

        """
        return _openmoc.Surface_getMaxX(self, halfspace)


    def getMinY(self, halfspace):
        """

        getMinY(int halfspace)=0 -> double  

        Returns the minimum y value for one of this Surface's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the minimum y value  

        """
        return _openmoc.Surface_getMinY(self, halfspace)


    def getMaxY(self, halfspace):
        """

        getMaxY(int halfspace)=0 -> double  

        Returns the maximum y value for one of this Surface's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the maximum y value  

        """
        return _openmoc.Surface_getMaxY(self, halfspace)


    def getMinZ(self, halfspace):
        """

        getMinZ(int halfspace)=0 -> double  

        Returns the minimum z value for one of this Surface's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the minimum z value  

        """
        return _openmoc.Surface_getMinZ(self, halfspace)


    def getMaxZ(self, halfspace):
        """

        getMaxZ(int halfspace)=0 -> double  

        Returns the maximum z value for one of this Surface's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the maximum z value  

        """
        return _openmoc.Surface_getMaxZ(self, halfspace)


    def setName(self, name):
        """

        setName(const char *name)  

        Sets the name of the Surface.  

        Parameters
        ----------
        * name :  
            the Surface name string  

        """
        return _openmoc.Surface_setName(self, name)


    def setBoundaryType(self, boundary_type):
        """

        setBoundaryType(const boundaryType boundary_type)  

        Sets the boundary condition type (ie, VACUUM or REFLECTIVE) for this Surface.  

        Parameters
        ----------
        * boundary_type :  
            the boundary condition type for this Surface  

        """
        return _openmoc.Surface_setBoundaryType(self, boundary_type)


    def addNeighborCell(self, halfspace, cell):
        """

        addNeighborCell(int halfspace, Cell *cell)  

        Adds a neighbor Cell to this Surface's collection of neighbors.  

        Parameters
        ----------
        * halfspace :  
            the +/-1 halfspace for the neighboring Cell  
        * cell :  
            a pointer to the neighboring Cell  

        """
        return _openmoc.Surface_addNeighborCell(self, halfspace, cell)


    def evaluate(self, point):
        """

        evaluate(const Point *point) const =0 -> double  

        Evaluate a Point using the Surface's potential equation.  

        This method returns the values $ f(x,y) $ for the potential function $f$ representing this
        Surface.  

        Parameters
        ----------
        * point :  
            a pointer to the Soint of interest  

        Returns
        -------
        the value of Point in the Plane's potential equation.  

        """
        return _openmoc.Surface_evaluate(self, point)


    def intersection(self, point, angle, points):
        """

        intersection(Point *point, double angle, Point *points)=0 -> int  

        Finds the intersection Point with this Surface from a given Point and trajectory defined
        by an angle.  

        Parameters
        ----------
        * point :  
            pointer to the Point of interest  
        * angle :  
            the angle defining the trajectory in radians  
        * points :  
            pointer to a Point to store the intersection Point  

        Returns
        -------
        the number of intersection Points (0 or 1)  

        """
        return _openmoc.Surface_intersection(self, point, angle, points)


    def isPointOnSurface(self, point):
        """

        isPointOnSurface(Point *point) -> bool  

        Return true or false if a Point is on or off of a Surface.  

        Parameters
        ----------
        * point :  
            pointer to the Point of interest  

        Returns
        -------
        on (true) or off (false) the Surface  

        """
        return _openmoc.Surface_isPointOnSurface(self, point)


    def isCoordOnSurface(self, coord):
        """

        isCoordOnSurface(LocalCoords *coord) -> bool  

        Return true or false if a LocalCoord is on or off of a Surface.  

        Parameters
        ----------
        * coord :  
            pointer to the LocalCoord of interest  

        Returns
        -------
        on (true) or off (false) the Surface  

        """
        return _openmoc.Surface_isCoordOnSurface(self, coord)


    def getMinDistance(self, coords):
        """

        getMinDistance(LocalCoords *coords) -> double  

        Finds the minimum distance to a Surface.  

        Finds the miniumum distance to a Surface from a LocalCoords with a trajectory defined by
        an angle to this Surface. If the trajectory will not intersect the Surface, returns
        INFINITY.  

        Parameters
        ----------
        * coords :  
            a pointer to a localcoords object  

        Returns
        -------
        the minimum distance to the Surface  

        """
        return _openmoc.Surface_getMinDistance(self, coords)


    def toString(self):
        """

        toString()=0 -> std::string  

        Converts this Surface's attributes to a character array.  

        The character array returned conatins the type of Surface (ie, PLANE) and the coefficients
        in the potential equation.  

        Returns
        -------
        a character array of this Surface's attributes  

        """
        return _openmoc.Surface_toString(self)


    def printString(self):
        """

        printString()  

        Prints a string representation of all of the Surface's objects to the console.  

        """
        return _openmoc.Surface_printString(self)

Surface_swigregister = _openmoc.Surface_swigregister
Surface_swigregister(Surface)

class Plane(Surface):
    """


    Represents a Plane perpendicular to the xy-plane.  

    C++ includes: src/Surface.h

    """
    __swig_setmethods__ = {}
    for _s in [Surface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Plane, name, value)
    __swig_getmethods__ = {}
    for _s in [Surface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Plane, name)
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """

        Plane(const double A, const double B, const double C, const double D, const int id=0,
            const char *name="")  

        Constructor.  

        Parameters
        ----------
        * A :  
            the first coefficient in $ A * x + B * y + C * z + D = 0 $  
        * B :  
            the second coefficient in $ A * x + B * y + C * z + D = 0 $  
        * C :  
            the third coefficient in $ A * x + B * y + C * z + D = 0 $  
        * D :  
            the fourth coefficient in $ A * x + B * y + C * z + D = 0 $  
        * id :  
            the optional Surface ID  
        * name :  
            the optional name of the Surface  

        """
        this = _openmoc.new_Plane(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getMinX(self, halfspace):
        """

        getMinX(int halfspace) -> double  

        Returns the minimum x value of -INFINITY.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the minimum x value of -INFINITY  

        """
        return _openmoc.Plane_getMinX(self, halfspace)


    def getMaxX(self, halfspace):
        """

        getMaxX(int halfspace) -> double  

        Returns the maximum x value of INFINITY.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the maximum x value of INFINITY  

        """
        return _openmoc.Plane_getMaxX(self, halfspace)


    def getMinY(self, halfspace):
        """

        getMinY(int halfspace) -> double  

        Returns the minimum y value of -INFINITY.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the minimum y value of -INFINITY  

        """
        return _openmoc.Plane_getMinY(self, halfspace)


    def getMaxY(self, halfspace):
        """

        getMaxY(int halfspace) -> double  

        Returns the maximum y value of INFINITY.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the maximum y value of INFINITY  

        """
        return _openmoc.Plane_getMaxY(self, halfspace)


    def getMinZ(self, halfspace):
        """

        getMinZ(int halfspace) -> double  

        Returns the minimum z value of -INFINITY.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the minimum z value of -INFINITY  

        """
        return _openmoc.Plane_getMinZ(self, halfspace)


    def getMaxZ(self, halfspace):
        """

        getMaxZ(int halfspace) -> double  

        Returns the maximum z value of INFINITY.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the Surface to consider  

        Returns
        -------
        the maximum z value of INFINITY  

        """
        return _openmoc.Plane_getMaxZ(self, halfspace)


    def getA(self):
        """

        getA() -> double  

        Returns the A coefficient multiplying x in the surface equation.  

        Returns
        -------
        the value for the A coefficient  

        """
        return _openmoc.Plane_getA(self)


    def getB(self):
        """

        getB() -> double  

        Returns the B coefficient multiplying y in the surface equation.  

        Returns
        -------
        the value for the B coefficient  

        """
        return _openmoc.Plane_getB(self)


    def getC(self):
        """

        getC() -> double  

        Returns the C coefficient multiplying z in the surface equation.  

        Returns
        -------
        the value for the C coefficient  

        """
        return _openmoc.Plane_getC(self)


    def getD(self):
        """

        getD() -> double  

        Returns the D constant coefficient.  

        Returns
        -------
        the value for the D coefficient  

        """
        return _openmoc.Plane_getD(self)


    def evaluate(self, point):
        """

        evaluate(const Point *point) const  -> double  

        Evaluate a Point using the Plane's quadratic Surface equation.  

        Parameters
        ----------
        * point :  
            a pointer to the Point of interest  

        Returns
        -------
        the value of Point in the Plane's quadratic equation  

        """
        return _openmoc.Plane_evaluate(self, point)


    def intersection(self, point, angle, points):
        """

        intersection(Point *point, double angle, Point *points) -> int  

        Finds the intersection Point with this Plane from a given Point and trajectory defined by
        an angle.  

        Parameters
        ----------
        * point :  
            pointer to the Point of interest  
        * angle :  
            the angle defining the trajectory in radians  
        * points :  
            pointer to a Point to store the intersection Point  

        Returns
        -------
        the number of intersection Points (0 or 1)  

        """
        return _openmoc.Plane_intersection(self, point, angle, points)


    def toString(self):
        """

        toString() -> std::string  

        Converts this Plane's attributes to a character array.  

        The character array returned conatins the type of Plane (ie, PLANE) and the A, B, and C
        coefficients in the quadratic Surface equation.  

        Returns
        -------
        a character array of this Plane's attributes  

        """
        return _openmoc.Plane_toString(self)

    __swig_destroy__ = _openmoc.delete_Plane
    __del__ = lambda self: None
Plane_swigregister = _openmoc.Plane_swigregister
Plane_swigregister(Plane)

class XPlane(Plane):
    """


    Represents a Plane perpendicular to the x-axis.  

    C++ includes: src/Surface.h

    """
    __swig_setmethods__ = {}
    for _s in [Plane]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, XPlane, name, value)
    __swig_getmethods__ = {}
    for _s in [Plane]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, XPlane, name)
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """

        XPlane(const double x, const int id=0, const char *name="")  

        Constructor for a Plane perpendicular to the x-axis.  

        Parameters
        ----------
        * x :  
            the location of the Plane along the x-axis  
        * id :  
            the optional Surface id  
        * name :  
            the optional name of the XPlane  

        """
        this = _openmoc.new_XPlane(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this

    def setX(self, x):
        """

        setX(const double x)  

        Set the location of this XPlane on the x-axis.  

        Parameters
        ----------
        * x :  
            the location of the XPlane on the x-axis  

        """
        return _openmoc.XPlane_setX(self, x)


    def getX(self):
        """

        getX() -> double  

        Returns the location of the XPlane on the x-axis.  

        Returns
        -------
        the location of the XPlane on the x-axis  

        """
        return _openmoc.XPlane_getX(self)


    def getMinX(self, halfspace):
        """

        getMinX(int halfspace) -> double  

        Returns the minimum x value for one of this XPlane's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the XPlane to consider  

        Returns
        -------
        the minimum x value  

        """
        return _openmoc.XPlane_getMinX(self, halfspace)


    def getMaxX(self, halfspace):
        """

        getMaxX(int halfspace) -> double  

        Returns the maximum x value for one of this XPlane's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the XPlane to consider  

        Returns
        -------
        the maximum x value  

        """
        return _openmoc.XPlane_getMaxX(self, halfspace)


    def toString(self):
        """

        toString() -> std::string  

        Converts this XPlane's attributes to a character array.  

        The character array returned conatins the type of Plane (ie, XPLANE) and the A, B, C, and
        D coefficients in the quadratic Surface equation and the location of the Plane on the
        x-axis.  

        Returns
        -------
        a character array of this XPlane's attributes  

        """
        return _openmoc.XPlane_toString(self)

    __swig_destroy__ = _openmoc.delete_XPlane
    __del__ = lambda self: None
XPlane_swigregister = _openmoc.XPlane_swigregister
XPlane_swigregister(XPlane)

class YPlane(Plane):
    """


    Represents a Plane perpendicular to the y-axis.  

    C++ includes: src/Surface.h

    """
    __swig_setmethods__ = {}
    for _s in [Plane]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, YPlane, name, value)
    __swig_getmethods__ = {}
    for _s in [Plane]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, YPlane, name)
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """

        YPlane(const double y, const int id=0, const char *name="")  

        Constructor for a Plane perpendicular to the y-axis.  

        Parameters
        ----------
        * y :  
            the location of the Plane along the y-axis  
        * id :  
            the optional Surface id  
        * name :  
            the optional Surface name  

        """
        this = _openmoc.new_YPlane(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this

    def setY(self, y):
        """

        setY(const double y)  

        Set the location of this YPlane on the y-axis.  

        Parameters
        ----------
        * y :  
            the location of the YPlane on the y-axis  

        """
        return _openmoc.YPlane_setY(self, y)


    def getY(self):
        """

        getY() -> double  

        Returns the location of the YPlane on the y-axis.  

        Returns
        -------
        the location of the YPlane on the y-axis  

        """
        return _openmoc.YPlane_getY(self)


    def getMinY(self, halfspace):
        """

        getMinY(int halfspace) -> double  

        Returns the minimum y value for one of this YPlane's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the YPlane to consider  

        Returns
        -------
        the minimum y value  

        """
        return _openmoc.YPlane_getMinY(self, halfspace)


    def getMaxY(self, halfspace):
        """

        getMaxY(int halfspace) -> double  

        Returns the maximum y value for one of this YPlane's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the YPlane to consider  

        Returns
        -------
        the maximum y value  

        """
        return _openmoc.YPlane_getMaxY(self, halfspace)


    def toString(self):
        """

        toString() -> std::string  

        Converts this yplane's attributes to a character array.  

        The character array returned conatins the type of Plane (ie, YPLANE) and the A, B, C, and
        D coefficients in the quadratic Surface equation and the location of the Plane on the
        y-axis.  

        Returns
        -------
        a character array of this YPlane's attributes  

        """
        return _openmoc.YPlane_toString(self)

    __swig_destroy__ = _openmoc.delete_YPlane
    __del__ = lambda self: None
YPlane_swigregister = _openmoc.YPlane_swigregister
YPlane_swigregister(YPlane)

class ZPlane(Plane):
    """


    Represents a Plane perpendicular to the z-axis.  

    C++ includes: src/Surface.h

    """
    __swig_setmethods__ = {}
    for _s in [Plane]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ZPlane, name, value)
    __swig_getmethods__ = {}
    for _s in [Plane]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ZPlane, name)
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """

        ZPlane(const double z, const int id=0, const char *name="")  

        Constructor for a Plane perpendicular to the z-axis.  

        Parameters
        ----------
        * z :  
            the location of the Plane along the z-axis  
        * id :  
            the optional Surface ID  
        * name :  
            the optional Surface name  

        """
        this = _openmoc.new_ZPlane(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this

    def setZ(self, z):
        """

        setZ(const double z)  

        Set the location of this ZPlane on the z-axis.  

        Parameters
        ----------
        * z :  
            the location of the ZPlane on the z-axis  

        """
        return _openmoc.ZPlane_setZ(self, z)


    def getZ(self):
        """

        getZ() -> double  

        Returns the location of the ZPlane on the z-axis.  

        Returns
        -------
        the location of the ZPlane on the z-axis  

        """
        return _openmoc.ZPlane_getZ(self)


    def getMinZ(self, halfspace):
        """

        getMinZ(int halfspace) -> double  

        Returns the minimum z value for one of this ZPlane's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the ZPlane to consider  

        Returns
        -------
        the minimum z value  

        """
        return _openmoc.ZPlane_getMinZ(self, halfspace)


    def getMaxZ(self, halfspace):
        """

        getMaxZ(int halfspace) -> double  

        Returns the maximum z value for one of this ZPlane's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the ZPlane to consider  

        Returns
        -------
        the maximum z value  

        """
        return _openmoc.ZPlane_getMaxZ(self, halfspace)


    def toString(self):
        """

        toString() -> std::string  

        Converts this ZPlane's attributes to a character array.  

        The character array returned conatins the type of Plane (ie, ZPLANE) and the A, B, C, and
        D coefficients in the quadratic Surface equation and the location of the Plane along the
        z-axis.  

        Returns
        -------
        a character array of this ZPlane's attributes  

        """
        return _openmoc.ZPlane_toString(self)

    __swig_destroy__ = _openmoc.delete_ZPlane
    __del__ = lambda self: None
ZPlane_swigregister = _openmoc.ZPlane_swigregister
ZPlane_swigregister(ZPlane)

class ZCylinder(Surface):
    """


    Represents a Cylinder with axis parallel to the z-axis.  

    C++ includes: src/Surface.h

    """
    __swig_setmethods__ = {}
    for _s in [Surface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ZCylinder, name, value)
    __swig_getmethods__ = {}
    for _s in [Surface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ZCylinder, name)
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """

        ZCylinder(const double x, const double y, const double radius, const int id=0, const char
            *name="")  

        constructor.  

        Parameters
        ----------
        * x :  
            the x-coordinte of the ZCylinder center  
        * y :  
            the y-coordinate of the ZCylinder center  
        * radius :  
            the radius of the ZCylinder  
        * id :  
            the optional Surface ID  
        * name :  
            the optional Surface name  

        """
        this = _openmoc.new_ZCylinder(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this

    def getX0(self):
        """

        getX0() -> double  

        Return the x-coordinate of the ZCylinder's center Point.  

        Returns
        -------
        the x-coordinate of the ZCylinder center  

        """
        return _openmoc.ZCylinder_getX0(self)


    def getY0(self):
        """

        getY0() -> double  

        Return the y-coordinate of the ZCylinder's center Point.  

        Returns
        -------
        the y-coordinate of the ZCylinder center  

        """
        return _openmoc.ZCylinder_getY0(self)


    def getRadius(self):
        """

        getRadius() -> double  

        Return the radius of the ZCylinder.  

        Returns
        -------
        the radius of the ZCylinder  

        """
        return _openmoc.ZCylinder_getRadius(self)


    def getMinX(self, halfspace):
        """

        getMinX(int halfspace) -> double  

        Returns the minimum x value for one of this ZCylinder's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the ZCylinder to consider  

        Returns
        -------
        the minimum x value  

        """
        return _openmoc.ZCylinder_getMinX(self, halfspace)


    def getMaxX(self, halfspace):
        """

        getMaxX(int halfspace) -> double  

        Returns the maximum x value for one of this ZCylinder's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the ZCylinder to consider  

        Returns
        -------
        the maximum x value  

        """
        return _openmoc.ZCylinder_getMaxX(self, halfspace)


    def getMinY(self, halfspace):
        """

        getMinY(int halfspace) -> double  

        Returns the minimum y value for one of this ZCylinder's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the ZCylinder to consider  

        Returns
        -------
        the minimum y value  

        """
        return _openmoc.ZCylinder_getMinY(self, halfspace)


    def getMaxY(self, halfspace):
        """

        getMaxY(int halfspace) -> double  

        Returns the maximum y value for one of this ZCylinder's halfspaces.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the ZCylinder to consider  

        Returns
        -------
        the maximum y value  

        """
        return _openmoc.ZCylinder_getMaxY(self, halfspace)


    def getMinZ(self, halfspace):
        """

        getMinZ(int halfspace) -> double  

        Returns the minimum z value of -INFINITY.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the ZCylinder to consider  

        Returns
        -------
        the minimum z value of -INFINITY  

        """
        return _openmoc.ZCylinder_getMinZ(self, halfspace)


    def getMaxZ(self, halfspace):
        """

        getMaxZ(int halfspace) -> double  

        Returns the maximum z value of INFINITY.  

        Parameters
        ----------
        * halfspace :  
            the halfspace of the ZCylinder to consider  

        Returns
        -------
        the maximum z value of INFINITY  

        """
        return _openmoc.ZCylinder_getMaxZ(self, halfspace)


    def evaluate(self, point):
        """

        evaluate(const Point *point) const  -> double  

        Evaluate a Point using the ZCylinder's quadratic Surface equation.  

        Parameters
        ----------
        * point :  
            a pointer to the Point of interest  

        Returns
        -------
        the value of Point in the equation  

        """
        return _openmoc.ZCylinder_evaluate(self, point)


    def intersection(self, point, angle, points):
        """

        intersection(Point *point, double angle, Point *points) -> int  

        Finds the intersection Point with this zcylinder from a given Point and trajectory defined
        by an angle (0, 1, or 2 points).  

        Parameters
        ----------
        * point :  
            pointer to the Point of interest  
        * angle :  
            the angle defining the trajectory in radians  
        * points :  
            pointer to a an array of Points to store intersection Points  
        * polar :  
            the polar angle defining the trajectory in radians  

        Returns
        -------
        the number of intersection Points (0 or 1)  

        """
        return _openmoc.ZCylinder_intersection(self, point, angle, points)


    def toString(self):
        """

        toString() -> std::string  

        Converts this ZCylinder's attributes to a character array.  

        The character array returned conatins the type of Plane (ie, ZCYLINDER) and the A, B, C, D
        and E coefficients in the quadratic Surface equation.  

        Returns
        -------
        a character array of this ZCylinder's attributes  

        """
        return _openmoc.ZCylinder_toString(self)

    __swig_destroy__ = _openmoc.delete_ZCylinder
    __del__ = lambda self: None
ZCylinder_swigregister = _openmoc.ZCylinder_swigregister
ZCylinder_swigregister(ZCylinder)

class Timer(_object):
    """


    The Timer class is for timing and profiling regions of code.  

    C++ includes: src/Timer.cpp

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Timer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Timer, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        Timer()  

        Constructor sets the current split elapsed time to zero.  

        """
        this = _openmoc.new_Timer()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Timer
    __del__ = lambda self: None

    def Get():
        """

        Get() -> Timer *  

        Returns a static instance of the Timer class.  

        Returns
        -------
        a pointer to the static Timer class  

        """
        return _openmoc.Timer_Get()

    if _newclass:
        Get = staticmethod(Get)
    __swig_getmethods__["Get"] = lambda x: Get

    def startTimer(self):
        """

        startTimer()  

        Starts the Timer.  

        This method is similar to starting a stopwatch.  

        """
        return _openmoc.Timer_startTimer(self)


    def stopTimer(self):
        """

        stopTimer()  

        Stops the Timer.  

        This method is similar to stopping a stopwatch.  

        """
        return _openmoc.Timer_stopTimer(self)


    def recordSplit(self, msg):
        """

        recordSplit(const char *msg)  

        Records a message corresponding to a time for the current split.  

        When this method is called it assumes that the Timer has been stopped and has the current
        time for the process corresponding to the message.  

        Parameters
        ----------
        * msg :  
            a msg corresponding to this time split  

        """
        return _openmoc.Timer_recordSplit(self, msg)


    def getTime(self):
        """

        getTime() -> double  

        Returns the time elapsed from startTimer() to stopTimer().  

        Returns
        -------
        the elapsed time in seconds  

        """
        return _openmoc.Timer_getTime(self)


    def getSplit(self, msg):
        """

        getSplit(const char *msg) -> double  

        Returns the time associated with a particular split.  

        If the split does not exist, returns 0.  

        Parameters
        ----------
        * msg :  
            the message tag for the split  

        Returns
        -------
        the time recorded for the split (seconds)  

        """
        return _openmoc.Timer_getSplit(self, msg)


    def printSplits(self):
        """

        printSplits()  

        Prints the times and messages for each split to the console.  

        This method will loop through all of the Timer's splits and print a formatted message
        string (80 characters in length) to the console with the message and the time
        corresponding to that message.  

        """
        return _openmoc.Timer_printSplits(self)


    def clearSplit(self, msg):
        """

        clearSplit(const char *msg)  

        Clears the time split for this message and deletes the message's entry in the Timer's
        splits log.  

        Parameters
        ----------
        * msg :  
            the message tag for the split  

        """
        return _openmoc.Timer_clearSplit(self, msg)


    def clearSplits(self):
        """

        clearSplits()  

        Clears all times split messages from the Timer.  

        """
        return _openmoc.Timer_clearSplits(self)

Timer_swigregister = _openmoc.Timer_swigregister
Timer_swigregister(Timer)

def Timer_Get():
    """

    Get() -> Timer *  

    Returns a static instance of the Timer class.  

    Returns
    -------
    a pointer to the static Timer class  

    """
    return _openmoc.Timer_Get()

class segment(_object):
    """


    A segment represents a line segment within a single flat source region along a track.  

    Attributes
    ----------
    * _length : FP_PRECISION  
        The length of the segment (cm)  

    * _material : Material *  
        A pointer to the material in which this segment resides  

    * _region_id : int  
        The ID for flat source region in which this segment resides  

    * _cmfd_surface_fwd : int  
        The ID for the mesh surface crossed by the Track end point  

    * _cmfd_surface_bwd : int  
        The ID for the mesh surface crossed by the Track start point  

    C++ includes: Track.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, segment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, segment, name)
    __repr__ = _swig_repr
    __swig_setmethods__["_length"] = _openmoc.segment__length_set
    __swig_getmethods__["_length"] = _openmoc.segment__length_get
    if _newclass:
        _length = _swig_property(_openmoc.segment__length_get, _openmoc.segment__length_set)
    __swig_setmethods__["_material"] = _openmoc.segment__material_set
    __swig_getmethods__["_material"] = _openmoc.segment__material_get
    if _newclass:
        _material = _swig_property(_openmoc.segment__material_get, _openmoc.segment__material_set)
    __swig_setmethods__["_region_id"] = _openmoc.segment__region_id_set
    __swig_getmethods__["_region_id"] = _openmoc.segment__region_id_get
    if _newclass:
        _region_id = _swig_property(_openmoc.segment__region_id_get, _openmoc.segment__region_id_set)
    __swig_setmethods__["_cmfd_surface_fwd"] = _openmoc.segment__cmfd_surface_fwd_set
    __swig_getmethods__["_cmfd_surface_fwd"] = _openmoc.segment__cmfd_surface_fwd_get
    if _newclass:
        _cmfd_surface_fwd = _swig_property(_openmoc.segment__cmfd_surface_fwd_get, _openmoc.segment__cmfd_surface_fwd_set)
    __swig_setmethods__["_cmfd_surface_bwd"] = _openmoc.segment__cmfd_surface_bwd_set
    __swig_getmethods__["_cmfd_surface_bwd"] = _openmoc.segment__cmfd_surface_bwd_get
    if _newclass:
        _cmfd_surface_bwd = _swig_property(_openmoc.segment__cmfd_surface_bwd_get, _openmoc.segment__cmfd_surface_bwd_set)

    def __init__(self):
        """

        segment()  

        Constructor initializes CMFD surfaces  

        """
        this = _openmoc.new_segment()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_segment
    __del__ = lambda self: None
segment_swigregister = _openmoc.segment_swigregister
segment_swigregister(segment)

class Track(_object):
    """


    A Track represents a characteristic line across the geometry.  

    A Track has particular starting and ending points on the boundaries of the geometry and an
    azimuthal angle.  

    C++ includes: src/Track.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Track, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Track, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        Track()  

        """
        this = _openmoc.new_Track()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Track
    __del__ = lambda self: None

    def setValues(self, start_x, start_y, start_z, end_x, end_y, end_z, phi):
        """

        setValues(const double start_x, const double start_y, const double start_z, const double
            end_x, const double end_y, const double end_z, const double phi)  

        Set the values for the Track's start and end point and angle.  

        Parameters
        ----------
        * start_x :  
            the x-coordinate at the starting point  
        * start_y :  
            the y-coordinate at the starting point  
        * start_z :  
            the z-coordinate at the starting point  
        * end_x :  
            the x-coordinate at the ending point  
        * end_y :  
            the y-coordinate at the ending point  
        * end_z :  
            the z-coordinate at the ending point  
        * phi :  
            the track's azimuthal angle ( $ \theta \in [0, \pi] $)  

        """
        return _openmoc.Track_setValues(self, start_x, start_y, start_z, end_x, end_y, end_z, phi)


    def setUid(self, uid):
        """

        setUid(int uid)  

        Initializes a Track's unique ID.  

        This is set by the trackgenerator to correspond to the Track's location in a 2D ragged
        array of all tracks.  

        Parameters
        ----------
        * uid :  
            the Track's unique ID  

        """
        return _openmoc.Track_setUid(self, uid)


    def setPhi(self, phi):
        """

        setPhi(const double phi)  

        Set the Track's azimuthal angle.  

        Parameters
        ----------
        * phi :  
            the azimuthal angle  

        """
        return _openmoc.Track_setPhi(self, phi)


    def setAzimAngleIndex(self, index):
        """

        setAzimAngleIndex(const int index)  

        Set the index for the Track's azimuthal angle index.  

        The azimuthal angle index corresponds to a an array of all azimuthal angles for $ \theta
        \in [0, \pi] $ owned by the TrackGenerator class.  

        Parameters
        ----------
        * index :  
            the azimuthal angle index  

        """
        return _openmoc.Track_setAzimAngleIndex(self, index)


    def setPeriodicTrackIndex(self, index):
        """

        setPeriodicTrackIndex(const int index)  

        Set the index of a track in a periodic cycle.  

        Tracks form periodic track cycles as they traverse the geometry. Tracks can be arbitrarily
        decomposed into periodic track cycles and this index indicates the index in a particular
        cycle.  

        Parameters
        ----------
        * index :  
            of the track in a periodic cycle  

        """
        return _openmoc.Track_setPeriodicTrackIndex(self, index)


    def setReflectiveTrackIndex(self, index):
        """

        setReflectiveTrackIndex(const int index)  

        Set the index of a track in a reflective cycle.  

        Tracks form reflective track cycles as they traverse the geometry. Tracks can be
        arbitrarily decomposed into reflective track cycles and this index indicates the index in
        a particular cycle.  

        Parameters
        ----------
        * index :  
            of the track in a reflective cycle  

        """
        return _openmoc.Track_setReflectiveTrackIndex(self, index)


    def setNextIn(self, next_in):
        """

        setNextIn(const bool next_in)  

        Sets the direction in which the flux leaving this Track along its "forward" direction is
        passed.  

        Sets whether or not to pass the outgoing flux from this Track along its "forward"
        direction to the "forward" direction (false) or "reverse" direction (true) of the next
        Track after intersection with the geometry boundary.  

        Parameters
        ----------
        * next_in :  
            the "forward" (false) or "reverse (true) direction  

        """
        return _openmoc.Track_setNextIn(self, next_in)


    def setNextOut(self, next_out):
        """

        setNextOut(const bool next_out)  

        Sets the direction in which the flux leaving this Track along its "reverse" direction is
        passed.  

        Sets whether or not to pass the outgoing flux from this Track along its "reverse"
        direction to the "forward" direction (false) or "reverse" direction (true) of the next
        Track after intersection with the geometry boundary.  

        Parameters
        ----------
        * next_out :  
            the "forward" (false) or "reverse (true) direction  

        """
        return _openmoc.Track_setNextOut(self, next_out)


    def setBCIn(self, bc_in):
        """

        setBCIn(const boundaryType bc_in)  

        Sets the boundary condition for the incoming flux along the Track's "forward" direction.  

        The boundaryType represents vacuum (0), reflective (1), or periodic (2) boundary
        conditions.  

        Parameters
        ----------
        * bc_in :  
            boundary condition for the incoming flux in the "forward" direction  

        """
        return _openmoc.Track_setBCIn(self, bc_in)


    def setBCOut(self, bc_out):
        """

        setBCOut(const boundaryType bc_out)  

        Sets the boundary condition for the incoming flux along the Track's "reverse" direction.  

        The boundaryType represents vacuum (0), reflective (1), or periodic (2) boundary
        conditions.  

        Parameters
        ----------
        * bc_out :  
            boundary condition for the incoming flux in the "reverse" direction  

        """
        return _openmoc.Track_setBCOut(self, bc_out)


    def setTrackIn(self, track_in):
        """

        setTrackIn(Track *track_in)  

        Sets the track going out along this Track's "forward" direction.  

        Parameters
        ----------
        * track_in :  
            pointer to the Track going out in the "forward" direction  

        """
        return _openmoc.Track_setTrackIn(self, track_in)


    def setTrackOut(self, track_out):
        """

        setTrackOut(Track *track_out)  

        Sets the track going out along this Track's "reverse" direction.  

        Parameters
        ----------
        * track_out :  
            pointer to the Track going out in the "reverse" direction  

        """
        return _openmoc.Track_setTrackOut(self, track_out)


    def getUid(self):
        """

        getUid() -> int  

        Return the Track's unique ID.  

        Returns
        -------
        the Track's unique ID  

        """
        return _openmoc.Track_getUid(self)


    def getEnd(self):
        """

        getEnd() -> Point *  

        Returns a pointer to the Track's end Point.  

        Returns
        -------
        a pointer to the Track's end Point  

        """
        return _openmoc.Track_getEnd(self)


    def getStart(self):
        """

        getStart() -> Point *  

        Returns a pointer to the Track's start Point.  

        Returns
        -------
        a pointer to the Track's start Point  

        """
        return _openmoc.Track_getStart(self)


    def getPhi(self):
        """

        getPhi() const  -> double  

        Return the Track's azimuthal angle (with respect to the x-axis).  

        Returns
        -------
        the azimuthal angle $ \theta \in [0, \pi] $  

        """
        return _openmoc.Track_getPhi(self)


    def getAzimAngleIndex(self):
        """

        getAzimAngleIndex() const  -> int  

        Return the index for the Track's azimuthal angle (with respect to the x-axis).  

        Returns
        -------
        th azimuthal angle index  

        """
        return _openmoc.Track_getAzimAngleIndex(self)


    def getPeriodicTrackIndex(self):
        """

        getPeriodicTrackIndex() const  -> int  

        Get the index of a track in a periodic cycle.  

        Returns
        -------
        index of the track in a periodic cycle  

        """
        return _openmoc.Track_getPeriodicTrackIndex(self)


    def getReflectiveTrackIndex(self):
        """

        getReflectiveTrackIndex() const  -> int  

        Get the index of a track in a reflective cycle.  

        Returns
        -------
        index of the track in a reflective cycle  

        """
        return _openmoc.Track_getReflectiveTrackIndex(self)


    def getSegment(self, s):
        """

        getSegment(int s) -> segment *  

        Returns a pointer to a segment with a given index.  

        Returns a pointer to the segment or ends program if Track does not have the requested
        segment.  

        Parameters
        ----------
        * segment :  
            index into the Track's segments container  

        Returns
        -------
        a pointer to the requested segment  

        """
        return _openmoc.Track_getSegment(self, s)


    def getSegments(self):
        """

        getSegments() -> segment *  

        Returns a vector of pointers to the Track's segments.  

        Returns
        -------
        vector of segment pointers  

        """
        return _openmoc.Track_getSegments(self)


    def getNumSegments(self):
        """

        getNumSegments() -> int  

        Return the number of segments along this Track.  

        Returns
        -------
        the number of segments  

        """
        return _openmoc.Track_getNumSegments(self)


    def getTrackIn(self):
        """

        getTrackIn() const  -> Track *  

        Returns the incoming Track.  

        Returns
        -------
        a pointer to the incoming Track  

        """
        return _openmoc.Track_getTrackIn(self)


    def getTrackOut(self):
        """

        getTrackOut() const  -> Track *  

        Returns the outgoing Track.  

        Returns
        -------
        a pointer to the outgoing Track  

        """
        return _openmoc.Track_getTrackOut(self)


    def isNextIn(self):
        """

        isNextIn() const  -> bool  

        Returns whether to give the outgoing flux to the "forward" (false) or "reverse" (true)
        direction of the next Track when traveling along this Tracks's "forward" direction.  

        Returns
        -------
        "forward" (false) "reverse" (true) direction of outgoing Track  

        """
        return _openmoc.Track_isNextIn(self)


    def isNextOut(self):
        """

        isNextOut() const  -> bool  

        Returns whether to give the outgoing flux to the "forward" (false) or "reverse" (true)
        direction of the next Track when traveling along this Track's "reverse" direction.  

        Returns
        -------
        "forward" (false) "reverse" (true) direction of outgoing Track  

        """
        return _openmoc.Track_isNextOut(self)


    def getBCIn(self):
        """

        getBCIn() const  -> boundaryType  

        Returns the boundary condition for the flux along the Track's "forward" direction.  

        Returns
        -------
        vacuum (0), reflective (1), or periodic (2) reflective boundary conditions  

        """
        return _openmoc.Track_getBCIn(self)


    def getBCOut(self):
        """

        getBCOut() const  -> boundaryType  

        Returns the boundary condition for the flux along the Track's "reverse" direction.  

        Returns
        -------
        vacuum (0), reflective (1), or periodic (2) reflective boundary conditions  

        """
        return _openmoc.Track_getBCOut(self)


    def getTransferFluxIn(self):
        """

        getTransferFluxIn() const  -> bool  

        Returns a boolean to indicate whether the outgoing flux along this Track's "forward"
        direction should be transferred to the outgoing Track.  

        The bool with be false for vacuum BCs and true for all other BCs.  

        Returns
        -------
        bool indicating whether the flux should be passed when tracking in the "forward"
        direction.  

        """
        return _openmoc.Track_getTransferFluxIn(self)


    def getTransferFluxOut(self):
        """

        getTransferFluxOut() const  -> bool  

        Returns a boolean to indicate whether the outgoing flux along this Track's "reverse"
        direction should be transferred to the incoming Track.  

        The bool with be false for vacuum BCs and true for all other BCs.  

        Returns
        -------
        bool indicating whether the flux should be passed when tracking in the "reverse"
        direction.  

        """
        return _openmoc.Track_getTransferFluxOut(self)


    def addSegment(self, to_add):
        """

        addSegment(segment *to_add)  

        Adds a segment pointer to this Track's list of segments.  

        This method assumes that segments are added in order of their starting location from the
        Track's start point.  

        Parameters
        ----------
        * to_add :  
            a pointer to the segment to add  

        """
        return _openmoc.Track_addSegment(self, to_add)


    def removeSegment(self, index):
        """

        removeSegment(int index)  

        Removes a segment from this Track's list of segments.  

        Parameters
        ----------
        * index :  
            the index of the segment to remove  

        """
        return _openmoc.Track_removeSegment(self, index)


    def insertSegment(self, index, segment):
        """

        insertSegment(int index, segment *segment)  

        Inserts a segment pointer into this Track's list of segments.  

        This method appends the new segment directly behind another segment in the Track. This is
        a helper method for the TrackGenerator::splitTracks(...) routine.  

        Parameters
        ----------
        * index :  
            the index of the segment to insert behind in the list  
        * segment :  
            a pointer to the segment to insert  

        """
        return _openmoc.Track_insertSegment(self, index, segment)


    def clearSegments(self):
        """

        clearSegments()  

        Deletes each of this Track's segments.  

        """
        return _openmoc.Track_clearSegments(self)


    def toString(self):
        """

        toString() -> std::string  

        Convert this Track's attributes to a character array.  

        The character array returned includes the Track's starting and ending coordinates, the
        azimuthal angle and azimuthal weight.  

        Returns
        -------
        a character array of this Track's attributes  

        """
        return _openmoc.Track_toString(self)

Track_swigregister = _openmoc.Track_swigregister
Track_swigregister(Track)

class TrackGenerator(_object):
    """


    The TrackGenerator is dedicated to generating and storing Tracks which cyclically wrap
    across the Geometry.  

    The TrackGenerator creates Track and initializes boundary conditions (vacuum, reflective,
    or periodic) for each Track.  

    C++ includes: src/TrackGenerator.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TrackGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TrackGenerator, name)
    __repr__ = _swig_repr

    def __init__(self, geometry, num_azim, azim_spacing):
        """

        TrackGenerator(Geometry *geometry, int num_azim, double azim_spacing)  

        Constructor for the TrackGenerator assigns default values.  

        Parameters
        ----------
        * geometry :  
            a pointer to a Geometry object  
        * num_azim :  
            number of azimuthal angles in $ [0, 2\pi] $  
        * azim_spacing :  
            azimuthal track spacing (cm)  

        """
        this = _openmoc.new_TrackGenerator(geometry, num_azim, azim_spacing)
        try:
            self.this.append(this)
        except:
            self.this = this

          # SWIG 3
        if 'geometry' in locals():
          geometry = locals()['geometry']
        elif 'args' in locals() and 'geometry' in locals()['args']:
          geometry = locals()['args']['geometry']
        elif 'kwargs' in locals() and 'geometry' in locals()['kwargs']:
          geometry = locals()['kwargs']['geometry']

        # SWIG 2
        else:
          geometry = locals()['args'][0]

        geometry.thisown = False



    __swig_destroy__ = _openmoc.delete_TrackGenerator
    __del__ = lambda self: None

    def getNumAzim(self):
        """

        getNumAzim() -> int  

        Return the number of azimuthal angles in $ [0, 2\pi] $.  

        Returns
        -------
        the number of azimuthal angles in $ 2\pi $  

        """
        return _openmoc.TrackGenerator_getNumAzim(self)


    def getNumPolarAngles(self):
        return _openmoc.TrackGenerator_getNumPolarAngles(self)

    def getDesiredAzimSpacing(self):
        """

        getDesiredAzimSpacing() -> double  

        Return the azimuthal track spacing (cm).  

        This will return the user-specified azimuthal track spacing and NOT the effective track
        spacing which is computed and used to generate cyclic tracks.  

        Returns
        -------
        the azimuthal track spacing (cm)  

        """
        return _openmoc.TrackGenerator_getDesiredAzimSpacing(self)


    def getPhi(self, azim):
        """

        getPhi(int azim) -> double  

        Returns the azimuthal angle for a given azimuthal angle index.  

        Parameters
        ----------
        * the :  
            azimuthal angle index.  

        Returns
        -------
        the desired azimuthal angle.  

        """
        return _openmoc.TrackGenerator_getPhi(self, azim)


    def getSinTheta(self, azim, polar):
        return _openmoc.TrackGenerator_getSinTheta(self, azim, polar)

    def getGeometry(self):
        """

        getGeometry() -> Geometry *  

        Return the Geometry for this TrackGenerator if one has been set.  

        Returns
        -------
        a pointer to the Geometry  

        """
        return _openmoc.TrackGenerator_getGeometry(self)


    def getQuadrature(self):
        """

        getQuadrature() -> Quadrature *  

        Returns a pointer to the Quadrature.  

        Returns
        -------
        a pointer to the Quadrature  

        """
        return _openmoc.TrackGenerator_getQuadrature(self)


    def getNumTracks(self):
        """

        getNumTracks() -> int  

        Return the total number of Tracks generated.  

        Returns
        -------
        The number of Tracks generated  

        """
        return _openmoc.TrackGenerator_getNumTracks(self)


    def getNumX(self, azim):
        """

        getNumX(int azim) -> int  

        Return the number of tracks on the x-axis for a given azimuthal angle.  

        Parameters
        ----------
        * azim :  
            An azimuthal angle index  

        Returns
        -------
        The number of Tracks on the x-axis  

        """
        return _openmoc.TrackGenerator_getNumX(self, azim)


    def getNumY(self, azim):
        """

        getNumY(int azim) -> int  

        Return the number of tracks on the y-axis for a given azimuthal angle.  

        Parameters
        ----------
        * azim :  
            An azimuthal angle index  

        Returns
        -------
        The number of Tracks on the y-axis  

        """
        return _openmoc.TrackGenerator_getNumY(self, azim)


    def getNumSegments(self):
        """

        getNumSegments() -> int  

        Return the total number of Track segments across the Geometry.  

        Returns
        -------
        the total number of Track segments  

        """
        return _openmoc.TrackGenerator_getNumSegments(self)


    def getTracks(self):
        """

        getTracks() -> Track **  

        Returns a 2D jagged array of the Tracks.  

        The first index into the array is the azimuthal angle and the second index is the Track
        number for a given azimuthal angle.  

        Returns
        -------
        the 2D jagged array of Tracks  

        """
        return _openmoc.TrackGenerator_getTracks(self)


    def getTracksArray(self):
        return _openmoc.TrackGenerator_getTracksArray(self)

    def retrieveMaxOpticalLength(self):
        return _openmoc.TrackGenerator_retrieveMaxOpticalLength(self)

    def getNumThreads(self):
        """

        getNumThreads() -> int  

        Returns the number of shared memory OpenMP threads in use.  

        Returns
        -------
        the number of threads  

        """
        return _openmoc.TrackGenerator_getNumThreads(self)


    def getFSRVolumes(self):
        """

        getFSRVolumes() -> FP_PRECISION *  

        Returns an array of volumes indexed by FSR.  

        Returns
        -------
        a pointer to the array of FSR volumes  

        """
        return _openmoc.TrackGenerator_getFSRVolumes(self)


    def getFSRVolume(self, fsr_id):
        """

        getFSRVolume(int fsr_id) -> FP_PRECISION  

        Computes and returns the volume of an FSR.  

        Parameters
        ----------
        * fsr_id :  
            the ID for the FSR of interest  

        Returns
        -------
        the FSR volume  

        """
        return _openmoc.TrackGenerator_getFSRVolume(self, fsr_id)


    def getMaxOpticalLength(self):
        """

        getMaxOpticalLength() -> FP_PRECISION  

        Finds and returns the maximum optical length amongst all segments.  

        Returns
        -------
        the maximum optical path length  

        """
        return _openmoc.TrackGenerator_getMaxOpticalLength(self)


    def getZCoord(self):
        """

        getZCoord() -> double  

        Returns the z-coord where the 2D Tracks should be created.  

        Returns
        -------
        the z-coord where the 2D Tracks should be created.  

        """
        return _openmoc.TrackGenerator_getZCoord(self)


    def getFSRLocks(self):
        """

        getFSRLocks() -> omp_lock_t *  

        Return the array of FSR locks for atomic FSR operations.  

        Returns
        -------
        an array of FSR locks  

        """
        return _openmoc.TrackGenerator_getFSRLocks(self)


    def getSegmentFormation(self):
        return _openmoc.TrackGenerator_getSegmentFormation(self)

    def setNumAzim(self, num_azim):
        """

        setNumAzim(int num_azim)  

        Set the number of azimuthal angles in $ [0, 2\pi] $.  

        Parameters
        ----------
        * num_azim :  
            the number of azimuthal angles in $ 2\pi $  

        """
        return _openmoc.TrackGenerator_setNumAzim(self, num_azim)


    def setDesiredAzimSpacing(self, azim_spacing):
        """

        setDesiredAzimSpacing(double azim_spacing)  

        Set the suggested azimuthal track spacing (cm).  

        Parameters
        ----------
        * azim_spacing :  
            the suggested azimuthal track spacing  

        """
        return _openmoc.TrackGenerator_setDesiredAzimSpacing(self, azim_spacing)


    def setGeometry(self, geometry):
        """

        setGeometry(Geometry *geometry)  

        Set a pointer to the Geometry to use for track generation.  

        Parameters
        ----------
        * geometry :  
            a pointer to the Geometry  

        """
        val = _openmoc.TrackGenerator_setGeometry(self, geometry)

          # SWIG 3
        if 'geometry' in locals():
          geometry = locals()['geometry']
        elif 'args' in locals() and 'geometry' in locals()['args']:
          geometry = locals()['args']['geometry']
        elif 'kwargs' in locals() and 'geometry' in locals()['kwargs']:
          geometry = locals()['kwargs']['geometry']

        # SWIG 2
        else:
          geometry = locals()['args'][0]

        geometry.thisown = False


        return val


    def setQuadrature(self, quadrature):
        """

        setQuadrature(Quadrature *quadrature)  

        Assign a Quadrature object to the Solver.  

        This routine allows use of a Quadrature with any polar angle quadrature. Alternatively,
        this routine may take in any subclass of the Quadrature parent class, including
        TYPolarQuad (default), LeonardPolarQuad, GLPolarQuad, etc.  

        Users may assign a Quadrature object to the Solver from Python script as follows:  


        Parameters
        ----------
        * quadrature :  
            a pointer to a Quadrature object  

        """
        val = _openmoc.TrackGenerator_setQuadrature(self, quadrature)

          # SWIG 3
        if 'quadrature' in locals():
          quadrature = locals()['quadrature']
        elif 'args' in locals() and 'quadrature' in locals()['args']:
          quadrature = locals()['args']['quadrature']
        elif 'kwargs' in locals() and 'quadrature' in locals()['kwargs']:
          quadrature = locals()['kwargs']['quadrature']

        # SWIG 2
        else:
          quadrature = locals()['args'][0]

        quadrature.thisown = False


        return val


    def setNumThreads(self, num_threads):
        """

        setNumThreads(int num_threads)  

        Sets the number of shared memory OpenMP threads to use (>0).  

        Parameters
        ----------
        * num_threads :  
            the number of threads  

        """
        return _openmoc.TrackGenerator_setNumThreads(self, num_threads)


    def setZCoord(self, z_coord):
        """

        setZCoord(double z_coord)  

        Sets the z-coord where the 2D Tracks should be created.  

        Parameters
        ----------
        * z_coord :  
            the z-coord where the 2D Tracks should be created.  

        """
        return _openmoc.TrackGenerator_setZCoord(self, z_coord)


    def setTracksFilenameSuffix(self, suffix):
        return _openmoc.TrackGenerator_setTracksFilenameSuffix(self, suffix)

    def containsTracks(self):
        """

        containsTracks() -> bool  

        Returns whether or not the TrackGenerator contains Track that are for its current number
        of azimuthal angles, track spacing and geometry.  

        Returns
        -------
        true if the TrackGenerator conatains Tracks; false otherwise  

        """
        return _openmoc.TrackGenerator_containsTracks(self)


    def retrieveTrackCoords(self, coords):
        """

        retrieveTrackCoords(double *coords, int num_tracks)  

        Fills an array with the x,y,z coordinates for each Track.  

        This class method is intended to be called by the OpenMOC Python "plotter" module as a
        utility to assist in plotting tracks. Although this method appears to require two
        arguments, in reality it only requires on due to SWIG and would be called from within
        Python as follows:  


        Parameters
        ----------
        * coords :  
            an array of coords of length NUM_VALUES_PER_RETRIEVED_TRACK times the number of Tracks  
        * length_coords :  
            the total number of Tracks times NUM_VALUES_PER_RETRIEVED_TRACK  

        """
        return _openmoc.TrackGenerator_retrieveTrackCoords(self, coords)


    def retrieveSegmentCoords(self, coords):
        """

        retrieveSegmentCoords(double *coords, int num_segments)  

        Fills an array with the x,y,z coordinates for each Track segment.  

        This class method is intended to be called by the OpenMOC Python "plotter" module as a
        utility to assist in plotting segments. Although this method appears to require two
        arguments, in reality it only requires one due to SWIG and would be called from within
        Python as follows:  


        Parameters
        ----------
        * coords :  
            an array of coords of length NUM_VALUES_PER_RETRIEVED_SEGMENT times the number of
            segments  
        * length_coords :  
            the total number of Track segments times NUM_VALUES_PER_RETRIEVED_SEGMENT  

        """
        return _openmoc.TrackGenerator_retrieveSegmentCoords(self, coords)


    def generateTracks(self, store=True, neighbor_cells=False):
        """

        generateTracks(bool store=true, bool neighbor_cells=false)  

        Generates tracks for some number of azimuthal angles and track spacing.  

        Computes the effective angles and track spacing. Computes the number of Tracks for each
        azimuthal angle, allocates memory for all Tracks at each angle and sets each Track's
        starting and ending Points, azimuthal angle, and azimuthal angle quadrature weight.
        neighbor_cells whether to use neighbor cell optimizations store whether to store the
        tracks to a file for reuse  

        """
        return _openmoc.TrackGenerator_generateTracks(self, store, neighbor_cells)


    def correctFSRVolume(self, fsr_id, fsr_volume):
        """

        correctFSRVolume(int fsr_id, FP_PRECISION fsr_volume)  

        Assign a correct volume for some FSR.  

        This routine adjusts the length of each track segment crossing a FSR such that the
        integrated volume is identical to the true volume assigned by the user.  

        Parameters
        ----------
        * fsr_id :  
            the ID of the FSR of interest  
        * fsr_volume :  
            the correct FSR volume to use  

        """
        return _openmoc.TrackGenerator_correctFSRVolume(self, fsr_id, fsr_volume)


    def generateFSRCentroids(self):
        """

        generateFSRCentroids()  

        Generates the numerical centroids of the FSRs.  

        This routine generates the numerical centroids of the FSRs by weighting the average x and
        y values of each segment in the FSR by the segment's length and azimuthal weight. The
        numerical centroid fomula can be found in R. Ferrer et. al. "Linear Source
                 Approximation in CASMO 5", PHYSOR 2012.  

        """
        return _openmoc.TrackGenerator_generateFSRCentroids(self)


    def splitSegments(self, max_optical_length):
        """

        splitSegments(FP_PRECISION max_optical_length)  

        Splits Track segments into sub-segments for a user-defined maximum optical length for the
        problem.  

        This routine is needed so that all segment lengths fit within the exponential
        interpolation table used in the MOC transport sweep.  

        Parameters
        ----------
        * max_optical_length :  
            the maximum optical length  

        """
        return _openmoc.TrackGenerator_splitSegments(self, max_optical_length)


    def initializeSegments(self):
        """

        initializeSegments()  

        Initialize track segments with pointers to FSR Materials.  

        This is called by the Solver at simulation time. This initialization is necessary since
        Materials in each FSR may be interchanged by the user in between different simulations.
        This method links each segment and fsr_data struct with the current Material found in each
        FSR.  

        """
        return _openmoc.TrackGenerator_initializeSegments(self)


    def printTimerReport(self):
        """

        printTimerReport()  

        Prints a report of the timing statistics to the console.  

        """
        return _openmoc.TrackGenerator_printTimerReport(self)


    def resetFSRVolumes(self):
        """

        resetFSRVolumes()  

        Deletes the memory associated with the FSR volumes and resets it NULL.  

        """
        return _openmoc.TrackGenerator_resetFSRVolumes(self)

TrackGenerator_swigregister = _openmoc.TrackGenerator_swigregister
TrackGenerator_swigregister(TrackGenerator)

class ExpEvaluator(_object):
    """


    This is a class for evaluating exponentials.  

    The ExpEvaluator includes different algorithms to evaluate exponentials with varying
    degrees of accuracy and speed. This is a helper class for the Solver and its subclasses
    and it not intended to be initialized as a standalone object.  

    C++ includes: src/ExpEvaluator.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpEvaluator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExpEvaluator, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        ExpEvaluator()  

        Constructor initializes array pointers to NULL.  

        The constructor sets the interpolation scheme as the default for computing exponentials.  

        """
        this = _openmoc.new_ExpEvaluator()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_ExpEvaluator
    __del__ = lambda self: None

    def setQuadrature(self, quadrature):
        """

        setQuadrature(Quadrature *quadrature)  

        Set the Quadrature to use when computing exponentials.  

        Parameters
        ----------
        * quadrature :  
            a Quadrature object pointer  

        """
        return _openmoc.ExpEvaluator_setQuadrature(self, quadrature)


    def setMaxOpticalLength(self, max_optical_length):
        """

        setMaxOpticalLength(FP_PRECISION max_optical_length)  

        Sets the maximum optical length covered in the exponential interpolation table.  

        Parameters
        ----------
        * max_optical_length :  
            the maximum optical length  

        """
        return _openmoc.ExpEvaluator_setMaxOpticalLength(self, max_optical_length)


    def setExpPrecision(self, exp_precision):
        """

        setExpPrecision(FP_PRECISION exp_precision)  

        Sets the maximum acceptable approximation error for exponentials.  

        This routine only affects the construction of the linear interpolation table for
        exponentials, if in use. By default, a value of 1E-5 is used for the table, as recommended
        by the analysis of Yamamoto in his 2004 paper on the subject.  

        Parameters
        ----------
        * exp_precision :  
            the maximum exponential approximation error  

        """
        return _openmoc.ExpEvaluator_setExpPrecision(self, exp_precision)


    def useInterpolation(self):
        """

        useInterpolation()  

        Use linear interpolation to compute exponentials.  

        """
        return _openmoc.ExpEvaluator_useInterpolation(self)


    def useIntrinsic(self):
        """

        useIntrinsic()  

        Use the exponential intrinsic exp(...) to compute exponentials.  

        """
        return _openmoc.ExpEvaluator_useIntrinsic(self)


    def getMaxOpticalLength(self):
        """

        getMaxOpticalLength() -> FP_PRECISION  

        Gets the maximum optical length covered with the exponential interpolation table.  

        Returns
        -------
        max_optical_length the maximum optical length  

        """
        return _openmoc.ExpEvaluator_getMaxOpticalLength(self)


    def getExpPrecision(self):
        """

        getExpPrecision() -> FP_PRECISION  

        Gets the maximum acceptable approximation error for exponentials.  

        Returns
        -------
        the maximum exponential approximation error  

        """
        return _openmoc.ExpEvaluator_getExpPrecision(self)


    def isUsingInterpolation(self):
        """

        isUsingInterpolation() -> bool  

        Returns true if using linear interpolation to compute exponentials.  

        Returns
        -------
        true if so, false otherwise  

        """
        return _openmoc.ExpEvaluator_isUsingInterpolation(self)


    def getTableSpacing(self):
        """

        getTableSpacing() -> FP_PRECISION  

        Returns the exponential table spacing.  

        Returns
        -------
        exponential table spacing  

        """
        return _openmoc.ExpEvaluator_getTableSpacing(self)


    def getTableSize(self):
        """

        getTableSize() -> int  

        Get the number of entries in the exponential interpolation table.  

        Parameters
        ----------
        * entries :  
            in the interpolation table  

        """
        return _openmoc.ExpEvaluator_getTableSize(self)


    def getExpTable(self):
        """

        getExpTable() -> FP_PRECISION *  

        Returns a pointer to the exponential interpolation table.  

        Returns
        -------
        pointer to the exponential interpolation table  

        """
        return _openmoc.ExpEvaluator_getExpTable(self)


    def initialize(self):
        """

        initialize()  

        If using linear interpolation, builds the table for each polar angle.  

        Parameters
        ----------
        * tolerance :  
            the minimum acceptable interpolation accuracy  

        """
        return _openmoc.ExpEvaluator_initialize(self)


    def computeExponential(self, tau, polar):
        """

        computeExponential(FP_PRECISION tau, int polar) -> FP_PRECISION  

        Computes the exponential term for a optical length and polar angle.  

        This method computes $ 1 - exp(-\tau/sin(\theta_p)) $ for some optical path length and
        polar angle. This method uses either a linear interpolation table (default) or the
        exponential intrinsic exp(...) function.  

        Parameters
        ----------
        * tau :  
            the optical path length (e.g., sigma_t times length)  
        * polar :  
            the polar angle index  

        Returns
        -------
        the evaluated exponential  

        """
        return _openmoc.ExpEvaluator_computeExponential(self, tau, polar)

ExpEvaluator_swigregister = _openmoc.ExpEvaluator_swigregister
ExpEvaluator_swigregister(ExpEvaluator)


def universe_id():
    """

    universe_id() -> int  

    Returns an auto-generated unique Universe ID.  

    This method is intended as a utility method for user's writing OpenMOC input files. The
    method makes use of a static Universe ID which is incremented each time the method is
    called to enable unique generation of monotonically increasing IDs. The method's first ID
    begins at 10000. Hence, user-defined Universe IDs greater than or equal to 10000 is
    prohibited.  

    """
    return _openmoc.universe_id()

def reset_universe_id():
    """

    reset_universe_id()  

    Resets the auto-generated unique Universe ID counter to 10000.  

    """
    return _openmoc.reset_universe_id()

def maximize_universe_id(universe_id):
    """

    maximize_universe_id(int universe_id)  

    Maximize the auto-generated unique Universe ID counter.  

    This method updates the auto-generated unique Universe ID counter if the input parameter
    is greater than the present value. This is useful for the OpenMC compatibility module to
    ensure that the auto-generated Universe IDs do not collide with those created in OpenMC.  

    Parameters
    ----------
    * universe_id :  
        the id assigned to the auto-generated counter  

    """
    return _openmoc.maximize_universe_id(universe_id)

_openmoc.SIMPLE_swigconstant(_openmoc)
SIMPLE = _openmoc.SIMPLE

_openmoc.LATTICE_swigconstant(_openmoc)
LATTICE = _openmoc.LATTICE
class Universe(_object):
    """


    A Universe represents an unbounded space in the 3D.  

    A Universe contains cell which are bounded subspaces in 3D which together form the
    Universe. Universes allow for complex, repeating (i.e. lattices) geometries to be simply
    represented with as few data structures as possible.  

    C++ includes: src/Universe.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Universe, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Universe, name)
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """

        Universe(const int id=-1, const char *name="")  

        Constructor assigns a unique and user-specified ID for the Universe.  

        Parameters
        ----------
        * id :  
            the user-specified optional Universe ID  
        * name :  
            the user-specified optional Universe ID  

        """
        this = _openmoc.new_Universe(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Universe
    __del__ = lambda self: None

    def getUid(self):
        """

        getUid() const  -> int  

        Returns the Universe's unique ID.  

        Returns
        -------
        the Universe's unique ID.  

        """
        return _openmoc.Universe_getUid(self)


    def getId(self):
        """

        getId() const  -> int  

        Return the user-specified ID for this Universe.  

        Returns
        -------
        the user-specified Universe ID  

        """
        return _openmoc.Universe_getId(self)


    def getName(self):
        """

        getName() const  -> char *  

        Return the user-defined name of the Universe.  

        Returns
        -------
        the Universe name  

        """
        return _openmoc.Universe_getName(self)


    def getType(self):
        """

        getType() -> universeType  

        Return the Universe type (SIMPLE or LATTICE).  

        Returns
        -------
        the Universe type  

        """
        return _openmoc.Universe_getType(self)


    def getNumCells(self):
        """

        getNumCells() const  -> int  

        Return the number of Cells in this Universe.  

        Returns
        -------
        the number of Cells  

        """
        return _openmoc.Universe_getNumCells(self)


    def getMinX(self):
        """

        getMinX() -> double  

        Aggregates a list (vector) of the IDs of all Materials within the MATERIAL type Cells
        filling this Universe.  

        Note that this method only searches the first level of Cells below this Universe within
        the nested Universe coordinate system.  

        Returns
        -------
        a vector of Material IDs  

        """
        return _openmoc.Universe_getMinX(self)


    def getMaxX(self):
        """

        getMaxX() -> double  

        Returns the maximum reachable x-coordinate in the Universe.  

        Returns
        -------
        the maximum reachable x-coordinate  

        """
        return _openmoc.Universe_getMaxX(self)


    def getMinY(self):
        """

        getMinY() -> double  

        Returns the minimum reachable y-coordinate in the Universe.  

        Returns
        -------
        the minimum reachable y-coordinate  

        """
        return _openmoc.Universe_getMinY(self)


    def getMaxY(self):
        """

        getMaxY() -> double  

        Returns the maximum reachable y-coordinate in the Universe.  

        Returns
        -------
        the maximum reachable y-coordinate  

        """
        return _openmoc.Universe_getMaxY(self)


    def getMinZ(self):
        """

        getMinZ() -> double  

        Returns the minimum reachable z-coordinate in the Universe.  

        Returns
        -------
        the minimum reachable z-coordinate  

        """
        return _openmoc.Universe_getMinZ(self)


    def getMaxZ(self):
        """

        getMaxZ() -> double  

        Returns the maximum reachable z-coordinate in the Universe.  

        Returns
        -------
        the maximum reachable z-coordinate  

        """
        return _openmoc.Universe_getMaxZ(self)


    def getMinXBoundaryType(self):
        """

        getMinXBoundaryType() -> boundaryType  

        Returns the boundary conditions (VACUUM or REFLECTIVE) at the minimum reachable
        x-coordinate in the Universe.  

        Returns
        -------
        the boundary conditions at the minimum reachable x-coordinate  

        """
        return _openmoc.Universe_getMinXBoundaryType(self)


    def getMaxXBoundaryType(self):
        """

        getMaxXBoundaryType() -> boundaryType  

        Returns the boundary conditions (VACUUM or REFLECTIVE) at the maximum reachable
        x-coordinate in the Universe.  

        Returns
        -------
        the boundary conditions at the maximum reachable x-coordinate  

        """
        return _openmoc.Universe_getMaxXBoundaryType(self)


    def getMinYBoundaryType(self):
        """

        getMinYBoundaryType() -> boundaryType  

        Returns the boundary conditions (VACUUM or REFLECTIVE) at the minimum reachable
        y-coordinate in the Universe.  

        Returns
        -------
        the boundary conditions at the minimum reachable y-coordinate  

        """
        return _openmoc.Universe_getMinYBoundaryType(self)


    def getMaxYBoundaryType(self):
        """

        getMaxYBoundaryType() -> boundaryType  

        Returns the boundary conditions (VACUUM or REFLECTIVE) at the maximum reachable
        y-coordinate in the Universe.  

        Returns
        -------
        the boundary conditions at the maximum reachable y-coordinate  

        """
        return _openmoc.Universe_getMaxYBoundaryType(self)


    def getCell(self, cell_id):
        """

        getCell(int cell_id) -> Cell *  

        Returns a Cell in this universe.  

        Parameters
        ----------
        * cell_id :  
            the integer the cell_id  

        Returns
        -------
        Returns the cell pointer.  

        """
        return _openmoc.Universe_getCell(self, cell_id)


    def getCells(self):
        """

        getCells() const  -> std::map< int, Cell * >  

        Return the container of Cell IDs and Cell pointers in this Universe.  

        Returns
        -------
        std::map of Cell IDs  

        """
        return _openmoc.Universe_getCells(self)


    def getAllCells(self):
        """

        getAllCells() -> std::map< int, Cell * >  

        Returns the std::map of Cell IDs and Cell pointers in this Universe at all nested Universe
        levels.  

        Returns
        -------
        std::map of Cell IDs and pointers  

        """
        return _openmoc.Universe_getAllCells(self)


    def getAllMaterials(self):
        """

        getAllMaterials() -> std::map< int, Material * >  

        Returns the std::map of all IDs and Material pointers filling this Universe.  

        Returns
        -------
        std::map of Material IDs and pointers  

        """
        return _openmoc.Universe_getAllMaterials(self)


    def getAllUniverses(self):
        """

        getAllUniverses() -> std::map< int, Universe * >  

        Returns the std::map of all nested Universe IDs and Universe pointers filling this
        Universe.  

        Returns
        -------
        std::map of Universe IDs and pointers  

        """
        return _openmoc.Universe_getAllUniverses(self)


    def isFissionable(self):
        """

        isFissionable() -> bool  

        Returns true if the Universe contains a Cell filled by a fissionable Material and false
        otherwise.  

        This method should not be called prior to the calling of the
        Geometry::computeFissionability() method.  

        Returns
        -------
        true if contains a fissionable Material  

        """
        return _openmoc.Universe_isFissionable(self)


    def setName(self, name):
        """

        setName(const char *name)  

        Sets the name of the Universe.  

        Parameters
        ----------
        * name :  
            the Universe name string  

        """
        return _openmoc.Universe_setName(self, name)


    def setType(self, type):
        """

        setType(universeType type)  

        Sets the Universe type to SIMPLE or LATTICE.  

        Parameters
        ----------
        * type :  
            the Universe type  

        """
        return _openmoc.Universe_setType(self, type)


    def addCell(self, cell):
        """

        addCell(Cell *cell)  

        Adds a Cell to this Universe.  

        Stores the user-specified Cell ID and Cell pointer in a std::map along with all of other
        Cells added to this Universe.  

        Parameters
        ----------
        * cell :  
            the Cell pointer  

        """
        val = _openmoc.Universe_addCell(self, cell)

          # SWIG 3
        if 'cell' in locals():
          cell = locals()['cell']
        elif 'args' in locals() and 'cell' in locals()['args']:
          cell = locals()['args']['cell']
        elif 'kwargs' in locals() and 'cell' in locals()['kwargs']:
          cell = locals()['kwargs']['cell']

        # SWIG 2
        else:
          cell = locals()['args'][0]

        cell.thisown = False


        return val


    def removeCell(self, cell):
        """

        removeCell(Cell *cell)  

        Removes a Cell from this Universe's container of Cells.  

        Parameters
        ----------
        * cell :  
            a pointer to the Cell to remove  

        """
        val = _openmoc.Universe_removeCell(self, cell)

          # SWIG 3
        if 'cell' in locals():
          cell = locals()['cell']
        elif 'args' in locals() and 'cell' in locals()['args']:
          cell = locals()['args']['cell']
        elif 'kwargs' in locals() and 'cell' in locals()['kwargs']:
          cell = locals()['kwargs']['cell']

        # SWIG 2
        else:
          cell = locals()['args'][0]

        cell.thisown = True


        return val


    def findCell(self, coords):
        """

        findCell(LocalCoords *coords) -> Cell *  

        Finds the Cell for which a LocalCoords object resides.  

        Finds the Cell that a LocalCoords object is located inside by checking each of this
        Universe's Cells. Returns NULL if the LocalCoords is not in any of the Cells.  

        Parameters
        ----------
        * coords :  
            a pointer to the LocalCoords of interest  

        Returns
        -------
        a pointer the Cell where the LocalCoords is located  

        """
        return _openmoc.Universe_findCell(self, coords)


    def setFissionability(self, fissionable):
        """

        setFissionability(bool fissionable)  

        Sets whether or not this Universe contains a fissionable Material with a non-zero fission
        cross-section.  

        This method is called by the Geometry::computeFissionability() class method.  

        Parameters
        ----------
        * fissionable :  
            true if the Universe contains a fissionable Material; false otherwise  

        """
        return _openmoc.Universe_setFissionability(self, fissionable)


    def subdivideCells(self, *args, **kwargs):
        """

        subdivideCells(double max_radius=INFINITY)  

        Subdivides all of the Material-filled Cells within this Universe into rings and angular
        sectors aligned with the z-axis.  

        Parameters
        ----------
        * max_radius :  
            the maximum allowable radius used in the subdivisions  

        """
        return _openmoc.Universe_subdivideCells(self, *args, **kwargs)


    def buildNeighbors(self):
        """

        buildNeighbors()  

        Builds collections of neighboring Cells for all Cells in this Universe for optimized ray
        tracing.  

        """
        return _openmoc.Universe_buildNeighbors(self)


    def toString(self):
        """

        toString() -> std::string  

        Convert the member attributes of this Universe to a character array.  

        Returns
        -------
        a character array representing the Universe's attributes  

        """
        return _openmoc.Universe_toString(self)


    def printString(self):
        """

        printString()  

        Prints a string representation of the Universe's attributes to the console.  

        """
        return _openmoc.Universe_printString(self)


    def clone(self):
        """

        clone() -> Universe *  

        Clones this Universe and copy cells map.  

        Returns
        -------
        a pointer to the Universe clone  

        """
        return _openmoc.Universe_clone(self)

Universe_swigregister = _openmoc.Universe_swigregister
Universe_swigregister(Universe)

class Lattice(Universe):
    """


    Represents a repeating 3D Lattice of Universes.  

    C++ includes: src/Universe.h

    """
    __swig_setmethods__ = {}
    for _s in [Universe]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Lattice, name, value)
    __swig_getmethods__ = {}
    for _s in [Universe]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Lattice, name)
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """

        Lattice(const int id=-1, const char *name="")  

        Constructor sets the user-specified and unique IDs for this Lattice.  

        Parameters
        ----------
        * id :  
            the user-specified optional Lattice (Universe) ID  
        * name :  
            the user-specified optional Lattice (Universe) name  

        """
        this = _openmoc.new_Lattice(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Lattice
    __del__ = lambda self: None

    def setOffset(self, x, y, z):
        """

        setOffset(double x, double y, double z)  

        Set the offset in global coordinates for this Lattice.  

        A lattice is assumed to be a rectilinear grid with the center/origin of the grid located
        in the center of the Lattice's parent universe. The offset represents the offset of the
        lattice center/origin with respect to the center of the parent universe. Therefore an
        offset of (-1,2) would move the center/origin of the lattice to the left 1 cm and up 2 cm.  

        Parameters
        ----------
        * x :  
            the offset in the x direction  
        * y :  
            the offset in the y direction  
        * z :  
            the offset in the z direction  

        """
        return _openmoc.Lattice_setOffset(self, x, y, z)


    def getOffset(self):
        """

        getOffset() -> Point *  

        Return a pointer to the offset for this Cell (in global coordinates).  

        Returns
        -------
        the offset of the Cell  

        """
        return _openmoc.Lattice_getOffset(self)


    def getNumX(self):
        """

        getNumX() const  -> int  

        Return the number of Lattice cells along the x-axis.  

        Returns
        -------
        the number of Lattice cells along x  

        """
        return _openmoc.Lattice_getNumX(self)


    def getNumY(self):
        """

        getNumY() const  -> int  

        Return the number of Lattice cells along the y-axis.  

        Returns
        -------
        the number of Lattice cells along y  

        """
        return _openmoc.Lattice_getNumY(self)


    def getNumZ(self):
        """

        getNumZ() const  -> int  

        Return the number of Lattice cells along the z-axis.  

        Returns
        -------
        the number of Lattice cells along z  

        """
        return _openmoc.Lattice_getNumZ(self)


    def getWidthX(self):
        """

        getWidthX() const  -> double  

        Return the width of the Lattice along the x-axis.  

        Returns
        -------
        the width of the Lattice cells along x  

        """
        return _openmoc.Lattice_getWidthX(self)


    def getWidthY(self):
        """

        getWidthY() const  -> double  

        Return the width of the Lattice along the y-axis.  

        Returns
        -------
        the width of the Lattice cells along y  

        """
        return _openmoc.Lattice_getWidthY(self)


    def getWidthZ(self):
        """

        getWidthZ() const  -> double  

        Return the width of the Lattice along the z-axis.  

        Returns
        -------
        the width of the Lattice cells along z  

        """
        return _openmoc.Lattice_getWidthZ(self)


    def getMinX(self):
        """

        getMinX() -> double  

        Returns the minimum reachable x-coordinate in the Lattice.  

        Returns
        -------
        the minimum reachable x-coordinate  

        """
        return _openmoc.Lattice_getMinX(self)


    def getMaxX(self):
        """

        getMaxX() -> double  

        Returns the maximum reachable x-coordinate in the Lattice.  

        Returns
        -------
        the maximum reachable x-coordinate  

        """
        return _openmoc.Lattice_getMaxX(self)


    def getMinY(self):
        """

        getMinY() -> double  

        Returns the minimum reachable y-coordinate in the Lattice.  

        Returns
        -------
        the minimum reachable y-coordinate  

        """
        return _openmoc.Lattice_getMinY(self)


    def getMaxY(self):
        """

        getMaxY() -> double  

        Returns the maximum reachable y-coordinate in the Lattice.  

        Returns
        -------
        the maximum reachable y-coordinate  

        """
        return _openmoc.Lattice_getMaxY(self)


    def getMinZ(self):
        """

        getMinZ() -> double  

        Returns the minimum reachable z-coordinate in the Lattice.  

        Returns
        -------
        the minimum reachable z-coordinate  

        """
        return _openmoc.Lattice_getMinZ(self)


    def getMaxZ(self):
        """

        getMaxZ() -> double  

        Returns the maximum reachable z-coordinate in the Lattice.  

        Returns
        -------
        the maximum reachable z-coordinate  

        """
        return _openmoc.Lattice_getMaxZ(self)


    def getUniverse(self, lat_x, lat_y, lat_z):
        """

        getUniverse(int lat_x, int lat_y, int lat_z) const  -> Universe *  

        Returns a pointer to the Universe within a specific Lattice cell.  

        Parameters
        ----------
        * lat_x :  
            the x index to the Lattice cell  
        * lat_y :  
            the y index to the Lattice cell  
        * lat_z :  
            the z index to the Lattice cell  

        Returns
        -------
        pointer to a Universe filling the Lattice cell  

        """
        return _openmoc.Lattice_getUniverse(self, lat_x, lat_y, lat_z)


    def getUniverses(self):
        """

        getUniverses() -> std::vector< std::vector< std::vector< std::pair< int, Universe * > > >
            > *  

        Return a 3D vector of the Universes in the Lattice.  

        Returns
        -------
        3D vector of Universes  

        """
        return _openmoc.Lattice_getUniverses(self)


    def getUniqueUniverses(self):
        """

        getUniqueUniverses() -> std::map< int, Universe * >  

        Aggregates a list (vector) of the IDs of all Universes within the FILL type Cells filling
        this Universe.  

        Note that this method only searches the first level of Cells below this Universe within
        the nested Universe coordinate system.  

        Returns
        -------
        a vector of Universe IDs  

        """
        return _openmoc.Lattice_getUniqueUniverses(self)


    def getAllCells(self):
        """

        getAllCells() -> std::map< int, Cell * >  

        Returns the std::map of Cell IDs and Cell pointers in this Lattice at all nested Universe
        levels.  

        Returns
        -------
        std::map of Cell IDs and pointers  

        """
        return _openmoc.Lattice_getAllCells(self)


    def getAllUniverses(self):
        """

        getAllUniverses() -> std::map< int, Universe * >  

        Returns the std::map of all nested Universe IDs and Universe pointers filling this
        Lattice.  

        Returns
        -------
        std::map of Universe IDs and pointers  

        """
        return _openmoc.Lattice_getAllUniverses(self)


    def setNumX(self, num_x):
        """

        setNumX(int num_x)  

        Set the number of Lattice cells along the x-axis.  

        Parameters
        ----------
        * num_x :  
            the number of Lattice cells along x  

        """
        return _openmoc.Lattice_setNumX(self, num_x)


    def setNumY(self, num_y):
        """

        setNumY(int num_y)  

        Set the number of Lattice cells along the y-axis.  

        Parameters
        ----------
        * num_y :  
            the number of Lattice cells along y  

        """
        return _openmoc.Lattice_setNumY(self, num_y)


    def setNumZ(self, num_z):
        """

        setNumZ(int num_z)  

        Set the number of Lattice cells along the z-axis.  

        Parameters
        ----------
        * num_z :  
            the number of Lattice cells along z  

        """
        return _openmoc.Lattice_setNumZ(self, num_z)


    def setWidth(self, *args, **kwargs):
        """

        setWidth(double width_x, double width_y, double width_z=std::numeric_limits< double
            >::infinity())  

        Set the width of each Lattice cell.  

        Parameters
        ----------
        * width_x :  
            the width along the x-axis in centimeters  
        * width_y :  
            the width along the y-axis in centimeters  
        * width_z :  
            the width along the z-axis in centimeters  

        """
        return _openmoc.Lattice_setWidth(self, *args, **kwargs)


    def setUniverses(self, num_z):
        """

        setUniverses(int num_z, int num_y, int num_x, Universe **universes)  

        Sets the array of Universe pointers filling each Lattice cell.  

        This is a helper method for SWIG to allow users to assign Universes to a Lattice using a
        3D Python list (list of lists of lists). An example how this method can be called from
        Python is as follows:  


        Parameters
        ----------
        * num_z :  
            the number of Lattice cells along z  
        * num_y :  
            the number of Lattice cells along y  
        * num_x :  
            the number of Lattice cells along x  
        * universes :  
            the array of Universes for each Lattice cell  

        """
        val = _openmoc.Lattice_setUniverses(self, num_z)

          # SWIG 3
        if 'num_z' in locals():
          universes = locals()['num_z']
        elif 'args' in locals() and 'num_z' in locals()['args']:
          universes = locals()['args']['num_z']
        elif 'kwargs' in locals() and 'num_z' in locals()['kwargs']:
          universes = locals()['kwargs']['num_z']

        # SWIG 2
        else:
          universes = locals()['args'][0]

        for i in range(len(universes)):
          for j in range(len(universes[i])):
            for k in range(len(universes[i][j])):
              universes[i][j][k].thisown = False


        return val


    def updateUniverse(self, lat_x, lat_y, lat_z, universe):
        """

        updateUniverse(int lat_x, int lat_y, int lat_z, Universe *universe)  

        Update the Universe in a particular Lattice cell.  

        This method may only be used after an array of Universes has been assigned with the
        Lattice::setUniverses(...) method.  

        Parameters
        ----------
        * lat_x :  
            the Lattice cell index along x  
        * lat_y :  
            the Lattice cell index along y  
        * lat_z :  
            the Lattice cell index along z  
        * universe :  
            the Universe to insert into the Lattice  

        """
        val = _openmoc.Lattice_updateUniverse(self, lat_x, lat_y, lat_z, universe)

          # SWIG 3
        if 'universe' in locals():
          universe = locals()['universe']
        elif 'args' in locals() and 'universe' in locals()['args']:
          universe = locals()['args']['universe']
        elif 'kwargs' in locals() and 'universe' in locals()['kwargs']:
          universe = locals()['kwargs']['universe']

        # SWIG 2
        else:
          universe = locals()['args'][3]

        universe.thisown = False


        return val


    def removeUniverse(self, universe):
        """

        removeUniverse(Universe *universe)  

        Removes all references to a Universe from the Lattice.  

        Parameters
        ----------
        * universe :  
            the Universe to remove  

        """
        val = _openmoc.Lattice_removeUniverse(self, universe)

          # SWIG 3
        if 'universe' in locals():
          universe = locals()['universe']
        elif 'args' in locals() and 'universe' in locals()['args']:
          universe = locals()['args']['universe']
        elif 'kwargs' in locals() and 'universe' in locals()['kwargs']:
          universe = locals()['kwargs']['universe']

        # SWIG 2
        else:
          universe = locals()['args'][0]

        universe.thisown = True


        return val


    def subdivideCells(self, *args, **kwargs):
        """

        subdivideCells(double max_radius=INFINITY)  

        Subdivides all of the Material-filled Cells within this Lattice into rings and angular
        sectors aligned with the z-axis.  

        Parameters
        ----------
        * max_radius :  
            the maximum allowable radius used in the subdivisions  

        """
        return _openmoc.Lattice_subdivideCells(self, *args, **kwargs)


    def buildNeighbors(self):
        """

        buildNeighbors()  

        Builds collections of neighboring Cells for all Cells in each Universe in the Lattice for
        optimized ray tracing.  

        """
        return _openmoc.Lattice_buildNeighbors(self)


    def withinBounds(self, point):
        """

        withinBounds(Point *point) -> bool  

        Checks if a Point is within the bounds of a Lattice.  

        Parameters
        ----------
        * point :  
            a pointer to the Point of interest  

        Returns
        -------
        true if the Point is in the bounds, false if not  

        """
        return _openmoc.Lattice_withinBounds(self, point)


    def findCell(self, coords):
        """

        findCell(LocalCoords *coords) -> Cell *  

        Finds the Cell within this Lattice that a LocalCoords is in.  

        This method first find the Lattice cell, then searches the Universe inside that Lattice
        cell. If LocalCoords is outside the bounds of the Lattice, this method will return NULL.  

        Parameters
        ----------
        * coords :  
            the LocalCoords of interest  

        Returns
        -------
        a pointer to the Cell this LocalCoord is in or NULL  

        """
        return _openmoc.Lattice_findCell(self, coords)


    def minSurfaceDist(self, coords):
        """

        minSurfaceDist(LocalCoords *coords) -> double  

        Finds the distance to the nearest surface.  

        Knowing that a Lattice must be cartesian, this function computes the distance to the
        nearest boundary between lattice cells in the direction of the track.  

        Parameters
        ----------
        * coords :  
            a pointer to a localcoords object  

        Returns
        -------
        the distance to the nearest Lattice cell boundary  

        """
        return _openmoc.Lattice_minSurfaceDist(self, coords)


    def getLatX(self, point):
        """

        getLatX(Point *point) -> int  

        Finds the Lattice cell x index that a point lies in.  

        Parameters
        ----------
        * point :  
            a pointer to a point being evaluated.  

        Returns
        -------
        the Lattice cell x index.  

        """
        return _openmoc.Lattice_getLatX(self, point)


    def getLatY(self, point):
        """

        getLatY(Point *point) -> int  

        Finds the Lattice cell y index that a point lies in.  

        Parameters
        ----------
        * point :  
            a pointer to a point being evaluated.  

        Returns
        -------
        the Lattice cell y index.  

        """
        return _openmoc.Lattice_getLatY(self, point)


    def getLatZ(self, point):
        """

        getLatZ(Point *point) -> int  

        Finds the Lattice cell z index that a point lies in.  

        Parameters
        ----------
        * point :  
            a pointer to a point being evaluated.  

        Returns
        -------
        the Lattice cell z index.  

        """
        return _openmoc.Lattice_getLatZ(self, point)


    def getLatticeCell(self, point):
        """

        getLatticeCell(Point *point) -> int  

        Finds the Lattice cell index that a point lies in.  

        Lattice cells are numbered starting with 0 x-min/y-min/z-min corner. Lattice cell IDs then
        increase monotonically from x-min to x-max, y-min to y-max, and z-min to z-max. Note that
        values increase first on the x-axis, followed by the y-axis, then on the z-axis. For
        example, the indices for a 4 x 4 x 1 lattice: 12 13 14 15 8 9 10 11 4 5 6 7 0 1 2 3  

        Parameters
        ----------
        * point :  
            a pointer to a point being evaluated.  

        Returns
        -------
        the Lattice cell index.  

        """
        return _openmoc.Lattice_getLatticeCell(self, point)


    def getLatticeSurface(self, cell, point):
        """

        getLatticeSurface(int cell, Point *point) -> int  

        Finds the Lattice cell surface that a point lies on. If the point is not on a surface, -1
        is returned.  

        The surface indices are defined in constants.h as they need to be consistent with the
        surface constant definitions used in Cmfd. The index returned takes into account the cell
        index and returns NUM_SURFACES*cell_index + surface_index.  

        Parameters
        ----------
        * cell :  
            the cell index that the point is in.  
        * point :  
            a pointer to a point being evaluated.  

        Returns
        -------
        the Lattice surface index.  

        """
        return _openmoc.Lattice_getLatticeSurface(self, cell, point)


    def getDistanceToSurface(self, cell, point, surface):
        """

        getDistanceToSurface(int cell, Point *point, int surface) -> double  

        Finds the distance from a point to a particular lattice cell surface.  

        Parameters
        ----------
        * cell :  
            the cell index that the point is in.  
        * point :  
            a pointer to a point being evaluated.  
        * surface :  
            a surface id to get the distance to.  

        Returns
        -------
        the distance to the lattice cell surface of interest.  

        """
        return _openmoc.Lattice_getDistanceToSurface(self, cell, point, surface)


    def toString(self):
        """

        toString() -> std::string  

        Converts a Lattice's attributes to a character array representation.  

        Returns
        -------
        character array of this Lattice's attributes  

        """
        return _openmoc.Lattice_toString(self)


    def printString(self):
        """

        printString()  

        Prints a string representation of all of the Lattice's attributes to the console.  

        """
        return _openmoc.Lattice_printString(self)

Lattice_swigregister = _openmoc.Lattice_swigregister
Lattice_swigregister(Lattice)


def stencilCompare(firstElem, secondElem):
    """

    stencilCompare(const std::pair< int, FP_PRECISION > &firstElem, const std::pair< int,
        FP_PRECISION > &secondElem) -> bool  

    Comparitor for sorting k-nearest stencil std::pair objects  

    """
    return _openmoc.stencilCompare(firstElem, secondElem)
class Cmfd(_object):
    """


    A class for Coarse Mesh Finite Difference (CMFD) acceleration.  

    C++ includes: src/Cmfd.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Cmfd, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Cmfd, name)
    __repr__ = _swig_repr

    def __init__(self):
        """

        Cmfd()  

        Constructor initializes boundaries and variables that describe the Cmfd object.  

        The construcor initializes the many variables that describe the CMFD mesh and are used to
        solve the nonlinear diffusion acceleration problem.  

        """
        this = _openmoc.new_Cmfd()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Cmfd
    __del__ = lambda self: None

    def computeKeff(self, moc_iteration):
        """

        computeKeff(int moc_iteration) -> FP_PRECISION  

        Solve the nonlinear diffusion acceleration problem to accelerate the convergence of the
        MOC problem.  

        This method uses the information from the last MOC transport sweep and solves a simplified
        nonlinear diffusion problem. The diffusion problem is tightly converged and the solution
        is used to update the the solution of the MOC problem.  

        Parameters
        ----------
        * moc_iteration :  
            MOC iteration number  

        Returns
        -------
        The dominant eigenvalue of the nonlinear diffusion problem  

        """
        return _openmoc.Cmfd_computeKeff(self, moc_iteration)


    def initialize(self):
        """

        initialize()  

        Initialize the Matrix and Vector objects, k-nearest stencils, the CMFD cell currents and
        MOC materials.  

        """
        return _openmoc.Cmfd_initialize(self)


    def initializeCellMap(self):
        """

        initializeCellMap()  

        Initializes the vector of vectors that links CMFD cells with FSRs.  

        This method is called by the geometry once the CMFD mesh has been initialized by the
        geometry. This method allocates a vector for each CMFD cell that is used to store the FSR
        ids contained within that cell.  

        """
        return _openmoc.Cmfd_initializeCellMap(self)


    def initializeGroupMap(self):
        """

        initializeGroupMap()  

        Initialize and set array that links the MOC energy groups to the CMFD energy groups.  

        This method initializes the _group_indices_map, which is a 1D array of length
        _num_moc_groups that maps the MOC energy groups to CMFD energy groups. The indices into
        _group_indices_map are the MOC energy groups and the values are the CMFD energy groups.  

        """
        return _openmoc.Cmfd_initializeGroupMap(self)


    def initializeLattice(self, offset):
        """

        initializeLattice(Point *offset)  

        Initialize the CMFD lattice.  

        """
        return _openmoc.Cmfd_initializeLattice(self, offset)


    def findCmfdCell(self, coords):
        """

        findCmfdCell(LocalCoords *coords) -> int  

        Find the CMFD cell that a LocalCoords object is in.  

        Parameters
        ----------
        * coords :  
            The coords being evaluated.  

        Returns
        -------
        The CMFD cell ID.  

        """
        return _openmoc.Cmfd_findCmfdCell(self, coords)


    def findCmfdSurface(self, cell_id, coords):
        """

        findCmfdSurface(int cell_id, LocalCoords *coords) -> int  

        Find the cmfd surface that a LocalCoords object lies on.  

        If the coords is not on a surface, -1 is returned. Otherwise, the surface ID is returned.  

        Parameters
        ----------
        * cell_id :  
            The CMFD cell ID that the local coords is in.  
        * coords :  
            The coords being evaluated.  

        Returns
        -------
        The surface ID.  

        """
        return _openmoc.Cmfd_findCmfdSurface(self, cell_id, coords)


    def addFSRToCell(self, cell_id, fsr_id):
        """

        addFSRToCell(int cell_id, int fsr_id)  

        Add an FSR ID to a vector that contains all the FSR IDs contained within a CMFD mesh cell.  

        Parameters
        ----------
        * cell_id :  
            The CMFD cell ID.  
        * fsr_id :  
            The FSR ID.  

        """
        return _openmoc.Cmfd_addFSRToCell(self, cell_id, fsr_id)


    def zeroCurrents(self):
        """

        zeroCurrents()  

        Zero the surface currents for each mesh cell and energy group.  

        """
        return _openmoc.Cmfd_zeroCurrents(self)


    def tallyCurrent(self, curr_segment, track_flux, azim_index, fwd):
        """

        tallyCurrent(segment *curr_segment, FP_PRECISION *track_flux, int azim_index, bool fwd)  

        Tallies the current contribution from this segment across the the appropriate CMFD mesh
        cell surface.  

        Parameters
        ----------
        * curr_segment :  
            The current Track segment  
        * track_flux :  
            The outgoing angular flux for this segment  
        * azim_index :  
            Azimuthal angle index of the current Track  
        * fwd :  
            Boolean indicating direction of integration along segment  

        """
        return _openmoc.Cmfd_tallyCurrent(self, curr_segment, track_flux, azim_index, fwd)


    def updateBoundaryFlux(self, tracks, boundary_flux, num_tracks):
        """

        updateBoundaryFlux(Track **tracks, FP_PRECISION *boundary_flux, int num_tracks)  

        Update the MOC boundary fluxes.  

        The MOC boundary fluxes are updated using the P0 approximation. With this approximation,
        the boundary fluxes are updated using the ratio of new to old flux for the cell that the
        outgoing flux from the track enters.  

        Parameters
        ----------
        * tracks :  
            2D array of Tracks  
        * boundary_flux :  
            Array of boundary fluxes  

        Returns
        -------
        The number of Tracks  

        """
        return _openmoc.Cmfd_updateBoundaryFlux(self, tracks, boundary_flux, num_tracks)


    def getNumCmfdGroups(self):
        """

        getNumCmfdGroups() -> int  

        Get the number of coarse CMFD energy groups.  

        Returns
        -------
        The number of CMFD energy groups  

        """
        return _openmoc.Cmfd_getNumCmfdGroups(self)


    def getNumMOCGroups(self):
        """

        getNumMOCGroups() -> int  

        Get the number of MOC energy groups.  

        Returns
        -------
        The number of MOC energy groups  

        """
        return _openmoc.Cmfd_getNumMOCGroups(self)


    def getNumCells(self):
        """

        getNumCells() -> int  

        Get the number of CMFD cells.  

        Returns
        -------
        The number of CMFD cells  

        """
        return _openmoc.Cmfd_getNumCells(self)


    def getCmfdGroup(self, group):
        """

        getCmfdGroup(int group) -> int  

        Get the CMFD group given an MOC group.  

        Parameters
        ----------
        * group :  
            The MOC energy group  

        Returns
        -------
        The CMFD energy group  

        """
        return _openmoc.Cmfd_getCmfdGroup(self, group)


    def getBoundary(self, side):
        """

        getBoundary(int side) -> int  

        Get the boundaryType for one side of the CMFD mesh.  

        Parameters
        ----------
        * side :  
            The CMFD mesh surface ID.  

        Returns
        -------
        The boundaryType for the surface.  

        """
        return _openmoc.Cmfd_getBoundary(self, side)


    def getLattice(self):
        """

        getLattice() -> Lattice *  

        Returns the Lattice object used as the CMFD mesh.  

        Returns
        -------
        A pointer to a Lattice object.  

        """
        return _openmoc.Cmfd_getLattice(self)


    def getNumX(self):
        """

        getNumX() -> int  

        Get the number of Mesh cells in a row.  

        Returns
        -------
        The number of Mesh cells in a row  

        """
        return _openmoc.Cmfd_getNumX(self)


    def getNumY(self):
        """

        getNumY() -> int  

        Get the number of Mesh cells in a column.  

        Returns
        -------
        The number of Mesh cells in a column  

        """
        return _openmoc.Cmfd_getNumY(self)


    def convertFSRIdToCmfdCell(self, fsr_id):
        """

        convertFSRIdToCmfdCell(int fsr_id) -> int  

        Return the CMFD cell ID that an FSR lies in.  

        Note that a CMFD cell is not an actual Cell object; rather, a CMFD cell is just a way of
        describing each of the rectangular regions that make up a CMFD lattice. CMFD cells are
        numbered with 0 in the lower left corner and monotonically increasing from left to right
        and from bottom to top. For example, the indices for a 4 x 4 lattice are: 12 13 14 15 8 9
        10 11 4 5 6 7 0 1 2 3  

        Parameters
        ----------
        * fsr_id :  
            The FSR ID.  

        Returns
        -------
        The CMFD cell ID. Return -1 if cell is not found.  

        """
        return _openmoc.Cmfd_convertFSRIdToCmfdCell(self, fsr_id)


    def getCellFSRs(self):
        """

        getCellFSRs() -> std::vector< std::vector< int > > *  

        Return a pointer to the vector of vectors that contains the FSRs that lie in each cell.  

        Returns
        -------
        Vector of vectors containing FSR IDs in each cell.  

        """
        return _openmoc.Cmfd_getCellFSRs(self)


    def isFluxUpdateOn(self):
        """

        isFluxUpdateOn() -> bool  

        Get flag indicating whether to update the MOC flux.  

        Returns
        -------
        Boolean saying whether to update MOC flux.  

        """
        return _openmoc.Cmfd_isFluxUpdateOn(self)


    def isCentroidUpdateOn(self):
        """

        isCentroidUpdateOn() -> bool  

        Get flag indicating whether to use FSR centroids to update the MOC flux.  

        Returns
        -------
        Flag saying whether to use centroids to update MOC flux.  

        """
        return _openmoc.Cmfd_isCentroidUpdateOn(self)


    def setSORRelaxationFactor(self, SOR_factor):
        """

        setSORRelaxationFactor(FP_PRECISION SOR_factor)  

        Set the successive over-relaxation factor for the linear solve within the diffusion
        eigenvalue solve.  

        Parameters
        ----------
        * SOR_factor :  
            Over-relaxation factor  

        """
        return _openmoc.Cmfd_setSORRelaxationFactor(self, SOR_factor)


    def setGeometry(self, geometry):
        """

        setGeometry(Geometry *geometry)  

        Set a pointer to the Geometry.  

        Parameters
        ----------
        * goemetry :  
            A pointer to a Geometry object.  

        """
        return _openmoc.Cmfd_setGeometry(self, geometry)


    def setWidthX(self, width):
        """

        setWidthX(double width)  

        Set Mesh width in the x-direction.  

        Parameters
        ----------
        * width :  
            Physical width of Mesh in the x-direction  

        """
        return _openmoc.Cmfd_setWidthX(self, width)


    def setWidthY(self, width):
        """

        setWidthY(double width)  

        Set Mesh width in the y-direction.  

        Parameters
        ----------
        * width :  
            Physical width of Mesh in the y-direction  

        """
        return _openmoc.Cmfd_setWidthY(self, width)


    def setNumX(self, num_x):
        """

        setNumX(int num_x)  

        Set the number of Mesh cells in a row.  

        Parameters
        ----------
        * num_x :  
            Number of Mesh cells in a row  

        """
        return _openmoc.Cmfd_setNumX(self, num_x)


    def setNumY(self, num_y):
        """

        setNumY(int num_y)  

        Set the number of Mesh cells in a column.  

        Parameters
        ----------
        * num_y :  
            Number of Mesh cells in a column  

        """
        return _openmoc.Cmfd_setNumY(self, num_y)


    def setNumFSRs(self, num_fsrs):
        """

        setNumFSRs(int num_fsrs)  

        Set the number of FSRs.  

        Parameters
        ----------
        * num_fsrs :  
            The number of FSRs  

        """
        return _openmoc.Cmfd_setNumFSRs(self, num_fsrs)


    def setNumMOCGroups(self, num_moc_groups):
        """

        setNumMOCGroups(int num_moc_groups)  

        Set the number of MOC energy groups.  

        Parameters
        ----------
        * num_groups :  
            Number of MOC energy groups  

        """
        return _openmoc.Cmfd_setNumMOCGroups(self, num_moc_groups)


    def setBoundary(self, side, boundary):
        """

        setBoundary(int side, boundaryType boundary)  

        Set the CMFD boundary type for a given surface.  

        The CMFD boundary is assumed to be rectangular with the surfaces identified by constants
        in the constants.h file.  

        Parameters
        ----------
        * side :  
            The CMFD surface UID.  
        * boundary :  
            The boundaryType of the surface.  

        """
        return _openmoc.Cmfd_setBoundary(self, side, boundary)


    def setLatticeStructure(self, num_x, num_y):
        """

        setLatticeStructure(int num_x, int num_y)  

        The structure of the Lattice to be used as the CMFD mesh.  

        Parameters
        ----------
        * num_x :  
            The number of cells in the x direction.  
        * num_y :  
            The number of cells in the y direction.  

        """
        return _openmoc.Cmfd_setLatticeStructure(self, num_x, num_y)


    def setFluxUpdateOn(self, flux_update_on):
        """

        setFluxUpdateOn(bool flux_update_on)  

        Set flag indicating whether to update the MOC flux.  

        Parameters
        ----------
        * flux_update_on :  
            Boolean saying whether to update MOC flux.  

        """
        return _openmoc.Cmfd_setFluxUpdateOn(self, flux_update_on)


    def setCentroidUpdateOn(self, centroid_update_on):
        """

        setCentroidUpdateOn(bool centroid_update_on)  

        Set flag indicating whether to use FSR centroids to update the MOC flux.  

        Parameters
        ----------
        * centroid_update_on :  
            Flag saying whether to use centroids to update MOC flux.  

        """
        return _openmoc.Cmfd_setCentroidUpdateOn(self, centroid_update_on)


    def setGroupStructure(self, group_indices):
        """

        setGroupStructure(std::vector< std::vector< int > > group_indices)  

        Set a coarse energy group structure for CMFD.  

        CMFD does not necessarily need to have the same energy group structure as the MOC problem.
        This function can be used to set a sparse energy group structure to speed up the CMFD
        solve. An example of how this may be called from Python to use a coarse 2-group CMFD
        structure atop a fine 7-group MOC structure is illustrated below:  


        Parameters
        ----------
        * group_indices :  
            A nested vector of MOC-to-CMFD group mapping  

        """
        return _openmoc.Cmfd_setGroupStructure(self, group_indices)


    def setSourceConvergenceThreshold(self, source_thresh):
        """

        setSourceConvergenceThreshold(FP_PRECISION source_thresh)  

        Sets the threshold for CMFD source convergence (>0)  

        Parameters
        ----------
        * the :  
            threshold for source convergence  

        """
        return _openmoc.Cmfd_setSourceConvergenceThreshold(self, source_thresh)


    def setQuadrature(self, quadrature):
        """

        setQuadrature(Quadrature *quadrature)  

        Sets the Quadrature object in use by the MOC Solver.  

        Parameters
        ----------
        * quadrature :  
            A Quadrature object pointer from the Solver  

        """
        return _openmoc.Cmfd_setQuadrature(self, quadrature)


    def setKNearest(self, k_nearest):
        """

        setKNearest(int k_nearest)  

        Set a number of k-nearest neighbor cells to use in updating the FSR flux.  

        Parameters
        ----------
        * k_nearest :  
            The number of nearest neighbor CMFD cells.  

        """
        return _openmoc.Cmfd_setKNearest(self, k_nearest)


    def setFSRMaterials(self, FSR_materials):
        """

        setFSRMaterials(Material **FSR_materials)  

        Set the FSR materials array pointer.  

        Parameters
        ----------
        * FSR_materials :  
            Pointer to FSR_materials array  

        """
        return _openmoc.Cmfd_setFSRMaterials(self, FSR_materials)


    def setFSRVolumes(self, FSR_volumes):
        """

        setFSRVolumes(FP_PRECISION *FSR_volumes)  

        Set the pointer to the array of FSR_volumes.  

        Parameters
        ----------
        * FSR_volumes :  
            Array of FSR volumes  

        """
        return _openmoc.Cmfd_setFSRVolumes(self, FSR_volumes)


    def setFSRFluxes(self, scalar_flux):
        """

        setFSRFluxes(FP_PRECISION *scalar_flux)  

        Set pointer to FSR flux array.  

        Parameters
        ----------
        * scalar_flux :  
            Pointer to FSR flux array  

        """
        return _openmoc.Cmfd_setFSRFluxes(self, scalar_flux)


    def setCellFSRs(self, cell_fsrs):
        """

        setCellFSRs(std::vector< std::vector< int > > *cell_fsrs)  

        Set the vector of vectors that contains the FSRs that lie in each cell.  

        Parameters
        ----------
        * cell_fsrs :  
            Vector of vectors containing FSR IDs in each cell.  

        """
        return _openmoc.Cmfd_setCellFSRs(self, cell_fsrs)

Cmfd_swigregister = _openmoc.Cmfd_swigregister
Cmfd_swigregister(Cmfd)

class Vector(_object):
    """


    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector, name)
    __repr__ = _swig_repr

    def __init__(self, cell_locks, num_x=1, num_y=1, num_groups=1):
        """

        Vector(omp_lock_t *cell_locks, int num_x=1, int num_y=1, int num_groups=1)  

        Constructor initializes Vector object as a floating point array and sets the vector
        dimensions.  The vector is ordered by cell (as opposed to by group) on the outside to be
        consistent with the Matrix object. Locks are used to make the vector object thread-safe
        against concurrent writes the same value. One lock locks out multiple rows of the vector
        at a time representing multiple groups in the same cell.  

        Parameters
        ----------
        * cell_locks :  
            OpenMP locks for atomic cell operations.  
        * num_x :  
            The number of cells in the x direction.  
        * num_y :  
            The number of cells in the y direction.  
        * num_groups :  
            The number of energy groups in each cell.  

        """
        this = _openmoc.new_Vector(cell_locks, num_x, num_y, num_groups)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Vector
    __del__ = lambda self: None

    def incrementValue(self, cell, group, val):
        """

        incrementValue(int cell, int group, FP_PRECISION val)  

        Increment a value in the vector.  This method takes a cell and group and floating point
        value. The cell and group are used to compute the row and column in the vector. If a value
        exists for the row, the value is incremented by val; otherwise, it is set to val.  

        Parameters
        ----------
        * cell :  
            The cell location.  
        * group :  
            The group location.  
        * val :  
            The value used to increment the row location.  

        """
        return _openmoc.Vector_incrementValue(self, cell, group, val)


    def incrementValues(self, cell, group_start, group_end, vals):
        """

        incrementValues(int cell, int group_start, int group_end, FP_PRECISION *vals)  

        Increment values in the vector.  This method takes a cell, first group, last group, and
        floating point value. The cell and groups are used to compute the rows in the vector. If
        values exist for the rows, the values are incremented by vals; otherwise, they are set.  

        Parameters
        ----------
        * cell :  
            The cell location.  
        * group_first :  
            The first group location to increment.  
        * group_last :  
            The last group location to increment.  
        * vals :  
            The values used to increment the row locations.  

        """
        return _openmoc.Vector_incrementValues(self, cell, group_start, group_end, vals)


    def clear(self):
        """

        clear()  

        Clear all values in the vector.  

        """
        return _openmoc.Vector_clear(self)


    def scaleByValue(self, val):
        """

        scaleByValue(FP_PRECISION val)  

        Scales the vector by a given value.  

        Parameters
        ----------
        * val :  
            The value to scale the vector by.  

        """
        return _openmoc.Vector_scaleByValue(self, val)


    def printString(self):
        """

        printString()  

        Print the vector object to the log file.  

        """
        return _openmoc.Vector_printString(self)


    def copyTo(self, vector):
        """

        copyTo(Vector *vector)  

        Copy the values from the current vector to an input vector.  

        Parameters
        ----------
        * vector :  
            The vector to copy values to.  

        """
        return _openmoc.Vector_copyTo(self, vector)


    def getValue(self, cell, group):
        """

        getValue(int cell, int group) -> FP_PRECISION  

        Get a value at location described by a given cell and group index.  

        Parameters
        ----------
        * cell :  
            The cell location index.  
        * group :  
            The group location index.  

        """
        return _openmoc.Vector_getValue(self, cell, group)


    def getArray(self):
        """

        getArray() -> FP_PRECISION *  

        Get the array describing the vector.  

        Returns
        -------
        The array describing the vector.  

        """
        return _openmoc.Vector_getArray(self)


    def getNumX(self):
        """

        getNumX() -> int  

        Get the number of cells in the x dimension.  

        Returns
        -------
        The number of cells in the x dimension.  

        """
        return _openmoc.Vector_getNumX(self)


    def getNumY(self):
        """

        getNumY() -> int  

        Get the number of cells in the y dimension.  

        Returns
        -------
        The number of cells in the y dimension.  

        """
        return _openmoc.Vector_getNumY(self)


    def getNumGroups(self):
        """

        getNumGroups() -> int  

        Get the number of groups in each cell.  

        Returns
        -------
        The number of groups in each cell.  

        """
        return _openmoc.Vector_getNumGroups(self)


    def getNumRows(self):
        """

        getNumRows() -> int  

        Get the number of rows in the vector.  

        Returns
        -------
        The number of rows in the vector.  

        """
        return _openmoc.Vector_getNumRows(self)


    def getSum(self):
        """

        getSum() -> FP_PRECISION  

        Get the sum of all the values in the vector.  

        Returns
        -------
        The sum of all the values in the vector.  

        """
        return _openmoc.Vector_getSum(self)


    def getCellLocks(self):
        """

        getCellLocks() -> omp_lock_t *  

        Return the array of cell locks for atomic cell operations.  

        Returns
        -------
        an array of cell locks  

        """
        return _openmoc.Vector_getCellLocks(self)


    def setValue(self, cell, group, val):
        """

        setValue(int cell, int group, FP_PRECISION val)  

        Set a value in the vector.  This method takes a cell and group and floating point value.
        The cell and group are used to compute the row and column in the vector. The location of
        the corresponding row is set to val.  

        Parameters
        ----------
        * cell :  
            The cell location.  
        * group :  
            The group location.  
        * val :  
            The value used to set the row location.  

        """
        return _openmoc.Vector_setValue(self, cell, group, val)


    def setValues(self, cell, group_start, group_end, vals):
        """

        setValues(int cell, int group_start, int group_end, FP_PRECISION *vals)  

        Set values in the vector.  This method takes a cell, first group, last group, and floating
        point value. The cell and groups are used to compute the rows in the vector. If a values
        exist for the rows, the values are overwritten.  

        Parameters
        ----------
        * cell :  
            The cell location.  
        * group_first :  
            The first group location to set.  
        * group_last :  
            The last group location to set.  
        * vals :  
            The values used to set the row locations.  

        """
        return _openmoc.Vector_setValues(self, cell, group_start, group_end, vals)


    def setAll(self, val):
        """

        setAll(FP_PRECISION val)  

        """
        return _openmoc.Vector_setAll(self, val)

Vector_swigregister = _openmoc.Vector_swigregister
Vector_swigregister(Vector)

class Matrix(_object):
    """


    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix, name)
    __repr__ = _swig_repr

    def __init__(self, cell_locks, num_x=1, num_y=1, num_groups=1):
        """

        Matrix(omp_lock_t *cell_locks, int num_x=1, int num_y=1, int num_groups=1)  

        Constructor initializes Matrix as a list of lists and sets the matrix dimensions.  The
        matrix object uses a "lists of lists" structure (implemented as a map of lists) to allow
        for easy setting and incrementing of the values in the object. When the matrix is needed
        to perform linear algebra operations, it is converted to compressed row storage (CSR) form
        [1]. The matrix is ordered by cell (as opposed to by group) on the outside. Locks are used
        to make the matrix thread-safe against concurrent writes the same value. One lock locks
        out multiple rows of the matrix at a time reprsenting multiple groups in the same cell.  

        [1] "Sparse matrix", Wikipedia, https://en.wikipedia.org/wiki/Sparse_matrix.  

        Parameters
        ----------
        * cell_locks :  
            Omp locks for atomic cell operations  
        * num_x :  
            The number of cells in the x direction.  
        * num_y :  
            The number of cells in the y direction.  
        * num_groups :  
            The number of energy groups in each cell.  

        """
        this = _openmoc.new_Matrix(cell_locks, num_x, num_y, num_groups)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openmoc.delete_Matrix
    __del__ = lambda self: None

    def incrementValue(self, cell_from, group_from, cell_to, group_to, val):
        """

        incrementValue(int cell_from, int group_from, int cell_to, int group_to, FP_PRECISION val)  

        Increment a value in the matrix.  This method takes a cell and group of origin (cell/group
        from) and cell and group of destination (cell/group to) and floating point value. The
        origin and destination are used to compute the row and column in the matrix. If a value
        exists for the row/column, the value is incremented by val; otherwise, it is set to val.  

        Parameters
        ----------
        * cell_from :  
            The origin cell.  
        * group_from :  
            The origin group.  
        * cell_to :  
            The destination cell.  
        * group_from :  
            The destination group.  
        * val :  
            The value used to increment the row/column location.  

        """
        return _openmoc.Matrix_incrementValue(self, cell_from, group_from, cell_to, group_to, val)


    def clear(self):
        """

        clear()  

        Clear all values in the matrix list of lists.  

        """
        return _openmoc.Matrix_clear(self)


    def printString(self):
        """

        printString()  

        Print the matrix object to the log file.  

        """
        return _openmoc.Matrix_printString(self)


    def transpose(self):
        """

        transpose()  

        Transpose the matrix in place.  

        """
        return _openmoc.Matrix_transpose(self)


    def getValue(self, cell_from, group_from, cell_to, group_to):
        """

        getValue(int cell_from, int group_from, int cell_to, int group_to) -> FP_PRECISION  

        Get a value in the matrix.  This method takes a cell and group of origin (cell/group from)
        and cell and group of destination (cell/group to). The origin and destination are used to
        compute the row and column in the matrix. The value at the location specified by the
        row/column is returned.  

        Parameters
        ----------
        * cell_from :  
            The origin cell.  
        * group_from :  
            The origin group.  
        * cell_to :  
            The destination cell.  
        * group_from :  
            The destination group.  

        Returns
        -------
        The value at the corresponding row/column location.  

        """
        return _openmoc.Matrix_getValue(self, cell_from, group_from, cell_to, group_to)


    def getLU(self):
        """

        getLU() -> FP_PRECISION *  

        Get the lower + upper (LU) component of the CSR form of the matrix object.  

        Returns
        -------
        A pointer to the lower + upper (LU) component of the CSR form matrix object.  

        """
        return _openmoc.Matrix_getLU(self)


    def getILU(self):
        """

        getILU() -> int *  

        Get an array of the row indices (I) component of the CSR form of the lower + upper (LU)
        components of the matrix.  

        Returns
        -------
        A pointer to the I component of the CSR form of the LU components of the matrix.  

        """
        return _openmoc.Matrix_getILU(self)


    def getJLU(self):
        """

        getJLU() -> int *  

        Get an array of the column indices (J) component of the CSR form of the lower + upper (LU)
        components of the matrix.  

        Returns
        -------
        A pointer to the J component of the CSR form of the LU components of the matrix.  

        """
        return _openmoc.Matrix_getJLU(self)


    def getNumX(self):
        """

        getNumX() -> int  

        Get the number of cells in the x dimension.  

        Returns
        -------
        The number of cells in the x dimension.  

        """
        return _openmoc.Matrix_getNumX(self)


    def getNumY(self):
        """

        getNumY() -> int  

        Get the number of cells in the y dimension.  

        Returns
        -------
        The number of cells in the y dimension.  

        """
        return _openmoc.Matrix_getNumY(self)


    def getNumGroups(self):
        """

        getNumGroups() -> int  

        Get the number of groups in each cell.  

        Returns
        -------
        The number of groups in each cell.  

        """
        return _openmoc.Matrix_getNumGroups(self)


    def getNumRows(self):
        """

        getNumRows() -> int  

        Get the number of rows in the matrix.  

        Returns
        -------
        The number of rows in the matrix.  

        """
        return _openmoc.Matrix_getNumRows(self)


    def getNNZ(self):
        """

        getNNZ() -> int  

        Get the number of non-zero values in the full matrix.  

        Returns
        -------
        The number of non-zero values in the full matrix.  

        """
        return _openmoc.Matrix_getNNZ(self)


    def getNNZLU(self):
        """

        getNNZLU() -> int  

        Get the number of non-zero values in the lower + upper components of the matrix.  

        Returns
        -------
        The number of non-zero values in the lower + upper components of the matrix.  

        """
        return _openmoc.Matrix_getNNZLU(self)


    def getCellLocks(self):
        """

        getCellLocks() -> omp_lock_t *  

        Return the array of cell locks for atomic cell operations.  

        Returns
        -------
        an array of cell locks  

        """
        return _openmoc.Matrix_getCellLocks(self)


    def setValue(self, cell_from, group_from, cell_to, group_to, val):
        """

        setValue(int cell_from, int group_from, int cell_to, int group_to, FP_PRECISION val)  

        Set a value in the matrix.  This method takes a cell and group of origin (cell/group from)
        and cell and group of destination (cell/group to) and floating point value. The origin and
        destination are used to compute the row and column in the matrix. The location specified
        by the row/column is set to val.  

        Parameters
        ----------
        * cell_from :  
            The origin cell.  
        * group_from :  
            The origin group.  
        * cell_to :  
            The destination cell.  
        * group_from :  
            The destination group.  
        * val :  
            The value used to set the row/column location.  

        """
        return _openmoc.Matrix_setValue(self, cell_from, group_from, cell_to, group_to, val)

Matrix_swigregister = _openmoc.Matrix_swigregister
Matrix_swigregister(Matrix)


def eigenvalueSolve(A, M, X, tol, SOR_factor=1.5):
    """

    eigenvalueSolve(Matrix *A, Matrix *M, Vector *X, FP_PRECISION tol, FP_PRECISION
        SOR_factor=1.5) -> FP_PRECISION  

    Solves a generalized eigenvalue problem using the Power method.  

    This function takes in a loss + streaming Matrix (A), a fission gain Matrix (M), a flux
    Vector (X), a tolerance used for both the power method and linear solve convergence (tol),
    and a successive over-relaxation factor (SOR_factor) and computes the dominant eigenvalue
    and eigenvector using the Power method. The eigenvalue is returned and the input X Vector
    is modified in place to be the corresponding eigenvector.  

    Parameters
    ----------
    * A :  
        the loss + streaming Matrix object  
    * M :  
        the fission gain Matrix object  
    * X :  
        the flux Vector object  
    * tol :  
        the power method and linear solve source convergence threshold  
    * SOR_factor :  
        the successive over-relaxation factor  

    Returns
    -------
    k_eff the dominant eigenvalue  

    """
    return _openmoc.eigenvalueSolve(A, M, X, tol, SOR_factor)

def linearSolve(A, M, X, B, tol, SOR_factor=1.5):
    """

    linearSolve(Matrix *A, Matrix *M, Vector *X, Vector *B, FP_PRECISION tol, FP_PRECISION
        SOR_factor=1.5)  

    Solves a linear system using Red-Black Gauss Seidel with successive over-relaxation.  

    This function takes in a loss + streaming Matrix (A), a fission gain Matrix (M), a flux
    Vector (X), a source Vector (B), a source convergence tolerance (tol) and a successive
    over-relaxation factor (SOR_factor) and computes the solution to the linear system. The
    input X Vector is modified in place to be the solution vector.  

    Parameters
    ----------
    * A :  
        the loss + streaming Matrix object  
    * M :  
        the fission gain Matrix object  
    * X :  
        the flux Vector object  
    * B :  
        the source Vector object  
    * tol :  
        the power method and linear solve source convergence threshold  
    * SOR_factor :  
        the successive over-relaxation factor  

    """
    return _openmoc.linearSolve(A, M, X, B, tol, SOR_factor)

def matrixMultiplication(A, X, B):
    """

    matrixMultiplication(Matrix *A, Vector *X, Vector *B)  

    Performs a matrix vector multiplication.  

    This function takes in a Matrix (A), a variable Vector (X), and a solution Vector (B) and
    computes the matrix vector product. The solution Vector is modified in place.  

    Parameters
    ----------
    * A :  
        a Matrix object  
    * X :  
        the variable Vector object  
    * B :  
        the solution Vector object  

    """
    return _openmoc.matrixMultiplication(A, X, B)

def computeRMSE(x, y, integrated):
    """

    computeRMSE(Vector *x, Vector *y, bool integrated) -> FP_PRECISION  

    Computes the Root Mean Square Error of two Vectors.  

    This function takes in two vectors (X and Y) and computes the Root Mean Square Error of
    the Vector Y with respect to Vector X. The boolean integrated must also be given to
    indicate whether the operation on the vector should be group-wise integrated before
    performing the RMSE operation.  

    Parameters
    ----------
    * X :  
        a Vector object  
    * Y :  
        a second Vector object  
    * integrated :  
        a boolean indicating whether to group-wise integrate.  

    """
    return _openmoc.computeRMSE(x, y, integrated)
# This file is compatible with both classic and new-style classes.


